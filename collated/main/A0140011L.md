# A0140011L
###### \java\teamfour\tasc\commons\events\ui\TaskPanelListChangedEvent.java
``` java
package teamfour.tasc.commons.events.ui;

import java.util.List;

import teamfour.tasc.commons.events.BaseEvent;
import teamfour.tasc.model.task.ReadOnlyTask;

/**
 * Represents a content change in the Task List panel.
 */
public class TaskPanelListChangedEvent extends BaseEvent {

    private final List<ReadOnlyTask> newTaskList;

    /**
     * Constructs a new event that signify
     * that the task list has been updated with a new list.
     * 
     * @param newTaskList contents
     */
    public TaskPanelListChangedEvent(List<ReadOnlyTask> newTaskList){
        this.newTaskList = newTaskList;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public List<ReadOnlyTask> getNewTaskList() {
        return newTaskList;
    }
}
```
###### \java\teamfour\tasc\commons\util\clock\Clock.java
``` java
package teamfour.tasc.commons.util.clock;

import java.util.Date;

/**
 * Represents a clock that can tell us the current time.
 */
public interface Clock {
    /**
     * Gets the current time provided by the clock.
     */
    Date getCurrentTime();
}
```
###### \java\teamfour\tasc\commons\util\clock\SystemClock.java
``` java
package teamfour.tasc.commons.util.clock;

import java.util.Date;

/**
 * Represents the current time on the computer.
 */
public class SystemClock implements Clock {

    /**
     * Gets the current time as determined by the system.
     */
    @Override
    public Date getCurrentTime() {

        /*
         * For those that are wondering why I didn't test
         * this method:
         * 
         * There is just no way to test such a 
         * time-sensitive method.
         * 
         * Do remember that DateUtil.setClock() allows 
         * replacement with fake clocks, to replace
         * SystemClock and fake the current timing 
         * for testing purposes.
         */    
        
        return new Date();
    }
}
```
###### \java\teamfour\tasc\commons\util\DateUtil.java
``` java
package teamfour.tasc.commons.util;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Date;

import teamfour.tasc.commons.util.clock.Clock;
import teamfour.tasc.commons.util.clock.SystemClock;

/**
 * Operations related to dates.
 */
public class DateUtil {    
    private static DateUtil singleton;
    
    private Clock clock;
    
    private DateUtil() {
        this.clock = new SystemClock();
    }
    
    /**
     * Get the singleton instance of DateUtil.
     */
    public static DateUtil getInstance() {
        if (singleton == null) {
            singleton = new DateUtil();
        }
        
        return singleton;
    }
    
    public void setClock(Clock newClock) {
        this.clock = newClock;
    }
    
    /**
     * Get the current time with regards to the clock
     * utilized by the DateUtil singleton.
     */
    public Date getCurrentTime() {
        return clock.getCurrentTime();
    }

    /**
     * Convert a java.util.Date to a java.time.LocalDateTime
     */
    public static LocalDateTime convertToLocalDateTime(Date date) {
        return date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
    }
    
    /**
     * Clamp the dateTime so that the latest hour can only be maxAllowedHour.
     */
    public static LocalDateTime clampDateTimeWithMaxAllowedHour(LocalDateTime dateTime,
            int maxAllowedHour) {
        if (dateTime.getHour() >= maxAllowedHour) {
            return dateTime.withHour(maxAllowedHour).withMinute(0);
        }

        return dateTime;
    }
}
```
###### \java\teamfour\tasc\logic\commands\CommandHelper.java
``` java
    /**
     * Converts the date object into a string that the pretty time parser
     * can actually understand.
     *
     * @param date to convert to
     * @return string that can be parsed by pretty time library
     */
    public static String convertDateToPrettyTimeParserFriendlyString(Date date) {
        return String.format("%tb %td %tY %tT", date, date, date, date);
    }
}
```
###### \java\teamfour\tasc\logic\commands\CompleteCommand.java
``` java
package teamfour.tasc.logic.commands;

import teamfour.tasc.commons.core.Messages;
import teamfour.tasc.commons.core.UnmodifiableObservableList;
import teamfour.tasc.commons.exceptions.IllegalValueException;
import teamfour.tasc.commons.util.DateUtil;
import teamfour.tasc.logic.keyword.CompleteCommandKeyword;
import teamfour.tasc.model.task.ReadOnlyTask;
import teamfour.tasc.model.task.UniqueTaskList.DuplicateTaskException;
import teamfour.tasc.model.task.UniqueTaskList.TaskNotFoundException;
import teamfour.tasc.model.task.exceptions.TaskAlreadyCompletedException;
import teamfour.tasc.model.task.util.TaskCompleteConverter;

/**
 * Marks a task as complete using the last displayed index from the task list.
 */
public class CompleteCommand extends Command {

    public static final String COMMAND_WORD = CompleteCommandKeyword.keyword;

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Mark as complete the task identified by the index number used "
            + "in the last task listing.\n" + "Parameters: INDEX (must be a positive integer)\n" + "Example: "
            + COMMAND_WORD + " 1";

    public static final String MESSAGE_COMPLETE_TASK_SUCCESS = "Completed Task: %1$s";
    public static final String MESSAGE_COMPLETE_TASK_UNDO_SUCCESS = "Marked task as uncompleted: %1$s";
    public static final String MESSAGE_COMPLETE_TASK_ALREADY_COMPLETED = "Task is already completed: %1$s";
    
    public static final String MESSAGE_COMPLETE_TASK_CANNOT_BE_FOUND = "Task cannot be found: %1$s";

    public final int targetIndex;

    private ReadOnlyTask oldReadOnlyTask;
    private TaskCompleteConverter newTasks;

    public CompleteCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        oldReadOnlyTask = lastShownList.get(targetIndex - 1);

        try {
            newTasks = new TaskCompleteConverter(oldReadOnlyTask, DateUtil.getInstance().getCurrentTime());
        } catch (TaskAlreadyCompletedException | IllegalValueException e) {
            return new CommandResult(
                    String.format(MESSAGE_COMPLETE_TASK_ALREADY_COMPLETED, oldReadOnlyTask));
        }

        try {
            model.updateTask(oldReadOnlyTask, newTasks.getCompletedTask());
            
            if (newTasks.getUncompletedRemainingRecurringTask() != null) {
                model.addTask(newTasks.getUncompletedRemainingRecurringTask());
            }
        } catch (TaskNotFoundException pnfe) {
            return new CommandResult(
                    String.format(MESSAGE_COMPLETE_TASK_CANNOT_BE_FOUND, oldReadOnlyTask));
        } catch (DuplicateTaskException dte) {
            assert false : "Not possible";
        }

        return new CommandResult(
                String.format(MESSAGE_COMPLETE_TASK_SUCCESS, newTasks.getCompletedTask()));
    }

    @Override
    public boolean canUndo() {
        return true;
    }

}
```
###### \java\teamfour\tasc\logic\commands\UpdateCommand.java
``` java
package teamfour.tasc.logic.commands;

import java.util.Date;
import java.util.List;
import java.util.Set;
import java.util.logging.Logger;

import teamfour.tasc.commons.core.EventsCenter;
import teamfour.tasc.commons.core.LogsCenter;
import teamfour.tasc.commons.core.Messages;
import teamfour.tasc.commons.core.UnmodifiableObservableList;
import teamfour.tasc.commons.events.ui.JumpToListRequestEvent;
import teamfour.tasc.commons.exceptions.IllegalValueException;
import teamfour.tasc.logic.keyword.UpdateCommandKeyword;
import teamfour.tasc.model.tag.Tag;
import teamfour.tasc.model.tag.UniqueTagList;
import teamfour.tasc.model.tag.UniqueTagList.DuplicateTagException;
import teamfour.tasc.model.tag.exceptions.TagNotFoundException;
import teamfour.tasc.model.task.Complete;
import teamfour.tasc.model.task.Deadline;
import teamfour.tasc.model.task.Name;
import teamfour.tasc.model.task.Period;
import teamfour.tasc.model.task.ReadOnlyTask;
import teamfour.tasc.model.task.Recurrence;
import teamfour.tasc.model.task.Task;
import teamfour.tasc.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Updates a task identified using it's last displayed index from the task list.
 */
public class UpdateCommand extends Command {

    public static final String COMMAND_WORD = UpdateCommandKeyword.keyword;

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Updates the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer) [name NAME] [by DEADLINE] "
            + "[from START_TIME to END_TIME] [repeatdeadline FREQUENCY COUNT] "
            + "[repeattime FREQUENCY COUNT] [tag \"TAG\"...]\n" + "Example: " + COMMAND_WORD
            + " 1 by 15 Sep 3pm";

    public static final String MESSAGE_UPDATE_TASK_SUCCESS = "Updated Task: %1$s";
    private static final String MESSAGE_UPDATE_TASK_UNDO_SUCCESS = 
            "Changes to task was reverted. Now: %1$s";
    private static final String MESSAGE_PERIOD_NEED_BOTH_START_AND_END_TIME = 
            "Period needs to have both start and end time.";

    public static final String PREFIX_REMOVE = "remove";

    public static final String KEYWORD_NAME = "name";
    public static final String KEYWORD_DEADLINE = "by";
    public static final String KEYWORD_PERIOD_START_TIME = "from";
    public static final String KEYWORD_PERIOD_END_TIME = "to";
    public static final String KEYWORD_RECURRENCE = "repeat";
    public static final String KEYWORD_TAG = "tag";

    public static final String KEYWORD_REMOVE_DEADLINE = PREFIX_REMOVE + KEYWORD_DEADLINE;
    public static final String KEYWORD_REMOVE_START_TIME = PREFIX_REMOVE
            + KEYWORD_PERIOD_START_TIME;
    public static final String KEYWORD_REMOVE_END_TIME = PREFIX_REMOVE + KEYWORD_PERIOD_END_TIME;
    public static final String KEYWORD_REMOVE_RECURRENCE = PREFIX_REMOVE
            + KEYWORD_RECURRENCE;
    public static final String KEYWORD_REMOVE_TAG = PREFIX_REMOVE + KEYWORD_TAG;

    public static final String[] VALID_KEYWORDS = { COMMAND_WORD, KEYWORD_NAME, KEYWORD_DEADLINE,
            KEYWORD_PERIOD_START_TIME, KEYWORD_PERIOD_END_TIME, KEYWORD_RECURRENCE, KEYWORD_TAG,
            KEYWORD_REMOVE_DEADLINE, KEYWORD_REMOVE_START_TIME, KEYWORD_REMOVE_END_TIME,
            KEYWORD_REMOVE_RECURRENCE, KEYWORD_REMOVE_TAG };

    public final int targetIndex;

    public final String updatedName;
    public final String updatedBy;
    public final String updatedStartTime;
    public final String updatedEndTime;
    public final String updatedRecurrence;
    public final Set<String> tagsToAdd;

    public final boolean removeDeadline;
    public final boolean removePeriod;
    public final boolean removeRecurrence;
    public final Set<String> tagsToRemove;
    
    private final Logger logger = LogsCenter.getLogger(UpdateCommand.class);

    private ReadOnlyTask oldReadOnlyTask;
    private Task newTask;

    /**
     * Constructs a new command for updating the details of a task.
     * 
     * Note: Parameters can be null, to indicate that no changes were made to
     * that particular detail.
     * 
     * @param targetIndex of the task to update
     */
    public UpdateCommand(int targetIndex, String newName, String newBy, String newStartTime,
            String newEndTime, String newRecurrence, Set<String> newTags, 
            boolean removeDeadline, boolean removePeriod, boolean removeRecurrence,
            Set<String> deleteTags) {
        this.targetIndex = targetIndex;

        this.updatedName = newName;
        this.updatedBy = newBy;
        this.updatedStartTime = newStartTime;
        this.updatedEndTime = newEndTime;
        this.updatedRecurrence = newRecurrence;
        this.tagsToAdd = newTags;

        this.removeDeadline = removeDeadline;
        this.removePeriod = removePeriod;
        this.removeRecurrence = removeRecurrence;
        this.tagsToRemove = deleteTags;
    }

    @Override
    public CommandResult execute() {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        oldReadOnlyTask = lastShownList.get(targetIndex - 1);
        try {
            newTask = createUpdatedTaskFromOldTask(oldReadOnlyTask);
        } catch (IllegalValueException ive) {
            return new CommandResult(ive.getMessage());
        }

        try {
            model.updateTask(oldReadOnlyTask, newTask);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }

        taskListSelectTask(targetIndex - 1);
        return new CommandResult(String.format(MESSAGE_UPDATE_TASK_SUCCESS, newTask));
    }
    
    /**
     * Simulates select command on the task in the task list
     */
    private void taskListSelectTask(int index) {
        EventsCenter.getInstance().post(new JumpToListRequestEvent(index));
    }

    @Override
    public boolean canUndo() {
        return true;
    }

    /**
     * Updates the task details of the old task by creating a new task with the
     * new updated details.
     * 
     * @param oldTask to be updated
     * @return the updated task with the new details
     */
    private Task createUpdatedTaskFromOldTask(ReadOnlyTask oldTask) throws IllegalValueException {
        Name newName = getUpdatedTaskName(oldTask);
        Complete newComplete = getUpdatedTaskCompleteStatus(oldTask);
        Deadline newDeadline = getUpdatedTaskDeadline(oldTask);
        Period newPeriod = getUpdatedTaskPeriod(oldTask);
        Recurrence newRecurrence = getUpdatedTaskRecurrence(oldTask);
        UniqueTagList newTags = getUpdatedTaskTags(oldTask);
        
        return new Task(newName, newComplete, newDeadline, newPeriod, newRecurrence, newTags);
    }
    
    /**
     * Gets the name of the updated task.
     * 
     * @param oldTask details before we executed the update command
     * @return the new name if the user requested to update it, otherwise
     * just return the old task's name.
     * @throws IllegalValueException if the name is invalid
     */
    private Name getUpdatedTaskName(ReadOnlyTask oldTask) throws IllegalValueException {
        if (this.updatedName != null) {
            return new Name(this.updatedName);
        }
        
        return oldTask.getName();        
    }
    
    /**
     * Gets the deadline of the updated task.
     * 
     * @param oldTask details before we executed the update command
     * @return the new deadline if the user requested to update it, otherwise
     * just return the old task's deadline.
     * @throws IllegalValueException if the deadline is invalid
     */
    private Deadline getUpdatedTaskDeadline(ReadOnlyTask oldTask) throws IllegalValueException {
        if (this.removeDeadline) {
            return new Deadline();
        }
        
        if (this.updatedBy != null) {
            return new Deadline(CommandHelper.convertStringToDate(this.updatedBy));
        }
        
        return oldTask.getDeadline();
    }
    
    /**
     * Gets the recurrence of the updated task.
     * 
     * @param oldTask details before we executed the update command
     * @return the new recurrence if the user requested to update it, otherwise
     * just return the old task's recurrence.
     * @throws IllegalValueException if the recurrence is invalid
     */
    private Recurrence getUpdatedTaskRecurrence(ReadOnlyTask oldTask) throws IllegalValueException {
        if (this.removeRecurrence) {
            return new Recurrence();
        }
        
        if (this.updatedRecurrence != null) {
            return CommandHelper.getRecurrence(this.updatedRecurrence);
        }
        
        return oldTask.getRecurrence();
    }
    
    /**
     * Gets the complete status of the updated task.
     * 
     * @param oldTask details before we executed the update command
     * @return the same as the old task, complete status cannot be changed by this command.
     * (Instead, must execute the complete command)
     */
    private Complete getUpdatedTaskCompleteStatus(ReadOnlyTask oldTask) {
        return oldTask.getComplete();
    }
    
    /**
     * Gets the period of the updated task.
     * 
     * @param oldTask details before we executed the update command
     * @return the new period if the user requested to update it, otherwise
     * just return the old task's period.
     * @throws IllegalValueException if the period is invalid
     */
    private Period getUpdatedTaskPeriod(ReadOnlyTask oldTask) throws IllegalValueException {
        if (this.removePeriod) {
            return new Period();
        }
        
        if (this.updatedStartTime != null || this.updatedEndTime != null) {
            return createNewPeriodFromCommandArguments(oldTask.getPeriod());
        }
        
        return oldTask.getPeriod();
    }

    /**
     * Gets the updated tags collection of the updated task.
     * 
     * @param oldTask details before we executed the update command
     * @return the new tags collection after we finish adding new tags
     * and removing old tags
     * @throws IllegalValueException if the tag is invalid
     */
    private UniqueTagList getUpdatedTaskTags(ReadOnlyTask oldTask) throws IllegalValueException {
        UniqueTagList result = oldTask.getTags();
        
        if (this.tagsToAdd != null) {
            for (String newTag : this.tagsToAdd) {
                try {
                    result.add(new Tag(newTag));
                } catch (DuplicateTagException dte) {
                    // do nothing (it is fine for the user to accidentally add
                    // the same tag)
                }
            }
        }

        if (this.tagsToRemove != null) {
            for (String redundantTag : this.tagsToRemove) {
                try {
                    result.remove(new Tag(redundantTag));
                } catch (TagNotFoundException tnfe) {
                    // do nothing (it is fine for the user to make a typo)
                }
            }
        }
        
        return result;
    }
    
    /**
     * Creates a new period object given the supplied arguments.
     * 
     * Pre-condition: The arguments MUST be provided. If the user
     * did not provide the arguments (i.e. did not intend to update
     * the period), do NOT call this method (see warning).
     * 
     * Warning: Methods other than {@link #getUpdatedTaskPeriod(ReadOnlyTask)}
     * should* NOT call this method directly. Call 
     * {@link #getUpdatedTaskPeriod(ReadOnlyTask)} instead to handle
     * cases where arguments may not be supplied,  or user requested
     * for period removal.
     * 
     * @param oldTaskPeriod
     * @return the updated period
     * @throws IllegalValueException if the command arguments are invalid
     */
    private Period createNewPeriodFromCommandArguments(Period oldTaskPeriod) throws IllegalValueException {
        if (this.updatedStartTime == null && oldTaskPeriod.getStartTime() == null) {
            throw new IllegalValueException(MESSAGE_PERIOD_NEED_BOTH_START_AND_END_TIME);
        }
        if (this.updatedEndTime == null && oldTaskPeriod.getEndTime() == null) {
            throw new IllegalValueException(MESSAGE_PERIOD_NEED_BOTH_START_AND_END_TIME);
        }
        
        String prettyTimeDatesString = "";
        int startDateIndex = 0;
        int endDateIndex = 1;
        
        if (this.updatedStartTime != null && this.updatedEndTime != null) {
            prettyTimeDatesString = this.updatedStartTime + " and " + this.updatedEndTime;
            
        } else if (this.updatedStartTime != null) {
            // must do it the other way round, otherwise Pretty Time will get confused :(
            prettyTimeDatesString = CommandHelper.convertDateToPrettyTimeParserFriendlyString(oldTaskPeriod.getEndTime()) +
                    " and " + this.updatedStartTime;            
            startDateIndex = 1;
            endDateIndex = 0;
            
        } else if (this.updatedEndTime != null) {
            prettyTimeDatesString = CommandHelper.convertDateToPrettyTimeParserFriendlyString(oldTaskPeriod.getStartTime()) +
                    " and " + this.updatedEndTime;
        }

        List<Date> finalDateOutput = CommandHelper.convertStringToMultipleDates(prettyTimeDatesString);
        if (finalDateOutput.size() == 2) {
            return new Period(finalDateOutput.get(startDateIndex), finalDateOutput.get(endDateIndex));
        } else {
            throw new IllegalValueException(MESSAGE_PERIOD_NEED_BOTH_START_AND_END_TIME);
        }
    }
}
```
###### \java\teamfour\tasc\logic\parser\Parser.java
``` java
    /**
     * Parses arguments in the context of the complete task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareComplete(String args) {

        Optional<Integer> index = parseIndex(args);
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, CompleteCommand.MESSAGE_USAGE));
        }

        return new CompleteCommand(index.get());
    }

    /**
     * Parses arguments in the context of the update task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareUpdate(String args) {
        final KeywordParser parser = new KeywordParser(UpdateCommand.VALID_KEYWORDS);
        HashMap<String, String> parsed = parser
                .parseKeywordsWithoutFixedOrder(UpdateCommand.COMMAND_WORD + args);

        Optional<Integer> targetIndex = parseIndex(parsed.get(UpdateCommand.COMMAND_WORD));
        if (!targetIndex.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
        }

        String name = parsed.get(UpdateCommand.KEYWORD_NAME);
        String deadline = parsed.get(UpdateCommand.KEYWORD_DEADLINE);
        String startTime = parsed.get(UpdateCommand.KEYWORD_PERIOD_START_TIME);
        String endTime = parsed.get(UpdateCommand.KEYWORD_PERIOD_END_TIME);
        String recurrence = parsed.get(UpdateCommand.KEYWORD_RECURRENCE);
        String addTagsArgs = parsed.get(UpdateCommand.KEYWORD_TAG);

        boolean removeDeadline = parsed.get(UpdateCommand.KEYWORD_REMOVE_DEADLINE) != null;
        boolean removePeriod = (parsed.get(UpdateCommand.KEYWORD_REMOVE_START_TIME) != null)
                || (parsed.get(UpdateCommand.KEYWORD_REMOVE_END_TIME) != null);
        boolean removeRecurrence = parsed.get(UpdateCommand.KEYWORD_REMOVE_RECURRENCE) != null;
        String removeTagsArgs = parsed.get(UpdateCommand.KEYWORD_REMOVE_TAG);

        Set<String> tagsToAdd = null;
        try {
            if (addTagsArgs != null) {
                tagsToAdd = getTagsFromArgs(addTagsArgs);
            }
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }

        Set<String> tagsToRemove = null;
        try {
            if (removeTagsArgs != null) {
                tagsToRemove = getTagsFromArgs(removeTagsArgs);
            }
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }

        return new UpdateCommand(targetIndex.get(), name, deadline, startTime, endTime, recurrence,
                tagsToAdd, removeDeadline, removePeriod, removeRecurrence, tagsToRemove);
    }

```
###### \java\teamfour\tasc\model\Model.java
``` java
    /**
     * Updates the old task by replacing it with
     * new task details.
     * 
     * @param oldTask to be replaced
     * @param newTask details
     * @throws TaskNotFoundException if the old task
     * cannot be found.
     */
    void updateTask(ReadOnlyTask oldTask, Task newTask) throws TaskNotFoundException;

```
###### \java\teamfour\tasc\model\ModelManager.java
``` java
    @Override
    public synchronized void updateTask(ReadOnlyTask oldTask, Task newTask) throws TaskNotFoundException {
        taskList.updateTask(oldTask, newTask);
        indicateTaskListChanged();
    }

```
###### \java\teamfour\tasc\model\task\Complete.java
``` java
package teamfour.tasc.model.task;

import java.util.Objects;

/**
 * Represents a task's completion status in the task list.
 * Guarantees: immutable
 */
public class Complete {
    public static final String TO_STRING_COMPLETED = "Completed";
    public static final String TO_STRING_NOT_COMPLETED = "Not Completed";
    
    private final boolean isCompleted;
    
    public Complete(boolean isCompleted) {
        this.isCompleted = isCompleted;
    }
    
    @Override
    public String toString() {
        return isCompleted() ? TO_STRING_COMPLETED : TO_STRING_NOT_COMPLETED;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Complete // instanceof handles nulls
                && this.isCompleted() == (((Complete) other).isCompleted())); // state check
    }

    @Override
    public int hashCode() {
        return Objects.hash(isCompleted());
    }

    public boolean isCompleted() {
        return isCompleted;
    }
}
```
###### \java\teamfour\tasc\model\task\Deadline.java
``` java
package teamfour.tasc.model.task;

import java.util.Date;
import java.util.Objects;

import teamfour.tasc.commons.util.ObjectUtil;

/**
 * Represents a task's deadline in the task list.
 * Guarantees: immutable;
 */
public class Deadline {
    public static final String TO_STRING_NO_DEADLINE = "No deadline.";
    
    private final boolean hasDeadline;
    private final Date deadline;
    
    /**
     * Constructor for no deadline.
     */
    public Deadline() {
        this.hasDeadline = false;
        this.deadline = null;
    }
    
    /**
     * Constructor for a given deadline.
     * 
     * Deadline should not be null.
     */
    public Deadline(Date deadline) {
        assert deadline != null;
        
        this.hasDeadline = true;
        this.deadline = deadline;
    }
    
    @Override
    public String toString() {
        if (hasDeadline()) {
            return getDeadline().toString();
        }
        
        return TO_STRING_NO_DEADLINE;
    }

    @Override
    public boolean equals(Object other) {
        if (other == this) { // short circuit if same object
            return true;
        }
        
        if (other instanceof Deadline == false) { // instanceof handles nulls
            return false;
        }
        
        Deadline otherDeadline = (Deadline)other;
        
        return ObjectUtil.isEquivalentOrBothNull(this.hasDeadline(), otherDeadline.hasDeadline()) &&
                ObjectUtil.isEquivalentOrBothNull(this.getDeadline(), otherDeadline.getDeadline()); // state check
    }

    @Override
    public int hashCode() {
        return Objects.hash(getDeadline());
    }

    public boolean hasDeadline() {
        return hasDeadline;
    }

    public Date getDeadline() {
        return deadline;
    }
    
    /** 
     * Given the current time, determines whether the task is overdue.
     * (Only make sense if task has a deadline).
     */
    public boolean isOverdue(Date currentTime) {
        if (!hasDeadline) {
            return false;
        }

        return currentTime.after(deadline);
    }
}
```
###### \java\teamfour\tasc\model\task\exceptions\TaskAlreadyCompletedException.java
``` java
package teamfour.tasc.model.task.exceptions;

/**
 * Represents an error whereby we try to mark a completed task
 * as complete again (which is an unnecessary action).
 */
public class TaskAlreadyCompletedException extends Exception {

}
```
###### \java\teamfour\tasc\model\task\Period.java
``` java
package teamfour.tasc.model.task;

import java.util.Date;
import java.util.Objects;

import teamfour.tasc.commons.exceptions.IllegalValueException;
import teamfour.tasc.commons.util.CollectionUtil;
import teamfour.tasc.commons.util.ObjectUtil;
import teamfour.tasc.model.task.status.EventStatus;

/**
 * Represents a task's period in the task list.
 * (from START_TIME to END_TIME)
 * 
 * Guarantees: immutable;
 */
public class Period {
    public static final String MESSAGE_PERIOD_CONSTRAINTS = "Start time should not be later than end time.";

    public static final String TO_STRING_FORMAT = "%s - %s";
    public static final String TO_STRING_NO_PERIOD = "No period.";
    
    private final boolean hasPeriod;
    private final Date startTime;
    private final Date endTime;
    
    /**
     * Constructor for no period given for task.
     */
    public Period() {
        this.hasPeriod = false;
        this.startTime = null;
        this.endTime = null;
    }
    
    /**
     * Constructor for a given period.
     * 
     * Timings should not be null and
     * period must be valid (see {@link #isValidPeriod(Date, Date)}).
     */
    public Period(Date startTime, Date endTime) throws IllegalValueException {
        assert !CollectionUtil.isAnyNull(startTime, endTime);
        
        if (!isValidPeriod(startTime, endTime)) {
            throw new IllegalValueException(MESSAGE_PERIOD_CONSTRAINTS);
        }
        
        this.hasPeriod = true;
        this.startTime = startTime;
        this.endTime = endTime;
    }

    /**
     * Returns true if given dates are not in the wrong order.
     * (i.e. Start Time < End Time)
     */
    private boolean isValidPeriod(Date startTime, Date endTime) {
        return startTime.before(endTime);
    }

    @Override
    public String toString() {
        if (hasPeriod()) {
            return String.format(TO_STRING_FORMAT, getStartTime(), getEndTime());
        }
        
        return TO_STRING_NO_PERIOD;
    }

    @Override
    public boolean equals(Object other) {
        if (other == this) { // short circuit if same object
            return true;
        }
        
        if (other instanceof Period == false) { // instanceof handles nulls
            return false;
        }
        
        Period otherPeriod = (Period)other;
        
        return ObjectUtil.isEquivalentOrBothNull(this.hasPeriod(), otherPeriod.hasPeriod()) &&
                ObjectUtil.isEquivalentOrBothNull(this.getStartTime(), otherPeriod.getStartTime()) &&
                ObjectUtil.isEquivalentOrBothNull(this.getEndTime(), otherPeriod.getEndTime()); // state check
    }

    @Override
    public int hashCode() {
        return Objects.hash(getStartTime(), getEndTime());
    }

    public boolean hasPeriod() {
        return hasPeriod;
    }

    public Date getStartTime() {
        return startTime;
    }

    public Date getEndTime() {
        return endTime;
    }
    
    /**
     * Get whether the event has started or not.
     */
    public EventStatus getEventStatus(Date currentTime) {
        if (!hasPeriod) {
            return EventStatus.NOT_AN_EVENT;
        }
        
        if (currentTime.before(startTime)) {
            return EventStatus.NOT_STARTED;
        }
        
        if (currentTime.after(endTime)) {
            return EventStatus.ENDED;
        }
        
        return EventStatus.IN_PROGRESS;
    }
}
```
###### \java\teamfour\tasc\model\task\ReadOnlyTask.java
``` java
    default boolean isFloatingTask() {
        return !getDeadline().hasDeadline() && !getPeriod().hasPeriod();
    }
    
    /** 
     * Given the current time, determines whether the task is overdue.
     * (Only make sense if task has a deadline).
     */
    default boolean isOverdue(Date currentTime) {
        return getDeadline().isOverdue(currentTime);
    }
    
    /**
     * Returns the event status: not started, started, or is over.
     */
    default EventStatus getEventStatus(Date currentTime) {
        return getPeriod().getEventStatus(currentTime);
    }
    
```
###### \java\teamfour\tasc\model\task\Recurrence.java
``` java
package teamfour.tasc.model.task;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Date;
import java.util.Objects;

import teamfour.tasc.commons.exceptions.IllegalValueException;
import teamfour.tasc.commons.util.ObjectUtil;

/**
 * Represents a task's recurrence (deadline, period, etc)
 * in the task list.
 * 
 * Guarantees: immutable;
 */
public class Recurrence {
    public enum Pattern {
        NONE, DAILY, WEEKLY, MONTHLY, YEARLY
    }

    public static final String MESSAGE_FREQUENCY_CONSTRAINT = "Frequency must be greater than 0.";
    
    public static final String TO_STRING_FORMAT = "%s [%d time(s)]";
    public static final String TO_STRING_NO_RECURRENCE = "No recurrence.";
    
    private final boolean hasRecurrence;
    private final Pattern pattern;
    private final int frequency;
    
    /**
     * Constructor for no recurrence.
     */
    public Recurrence() {
        this.hasRecurrence = false;
        this.pattern = Pattern.NONE;
        this.frequency = 0;
    }
    
    /**
     * Constructor for a given recurring pattern.
     * 
     * Pattern should not be null and frequency
     * must be valid (see {@link #isValidFrequency(int)}).
     * Pattern should not be NONE, call the default constructor
     * for such patterns.
     */
    public Recurrence(Pattern pattern, int frequency) throws IllegalValueException {
        assert pattern != null;
        assert pattern != Pattern.NONE;
        
        if (!isValidFrequency(frequency)) {
            throw new IllegalValueException(MESSAGE_FREQUENCY_CONSTRAINT);
        }
        
        this.hasRecurrence = true;
        this.pattern = pattern;
        this.frequency = frequency;
    }

    /**
     * Checks whether the frequency is valid or not.
     * (Frequency cannot be negative or zero)
     */
    private boolean isValidFrequency(int frequency) {
        return frequency > 0;
    }

    
    @Override
    public String toString() {
        if (hasRecurrence()) {
            return String.format(TO_STRING_FORMAT, getPattern().toString(), getFrequency());
        }
        
        return TO_STRING_NO_RECURRENCE;
    }

    @Override
    public boolean equals(Object other) {
        if (other == this) { // short circuit if same object
            return true;
        }
        
        if (other instanceof Recurrence == false) { // instanceof handles nulls
            return false;
        }
        
        Recurrence otherRecurrence = (Recurrence)other;
        
        return ObjectUtil.isEquivalentOrBothNull(this.hasRecurrence(), otherRecurrence.hasRecurrence()) &&
                ObjectUtil.isEquivalentOrBothNull(this.getPattern(), otherRecurrence.getPattern()) &&
                ObjectUtil.isEquivalentOrBothNull(this.getFrequency(), otherRecurrence.getFrequency()); // state checkk
    
    }

    @Override
    public int hashCode() {
        return Objects.hash(getPattern(), getFrequency());
    }

    public boolean hasRecurrence() {
        return hasRecurrence;
    }

    public Pattern getPattern() {
        return pattern;
    }

    public int getFrequency() {
        return frequency;
    }
    
    /**
     * Get the next recurrence date according to the pattern that
     * we have
     * @param currentDate to base our next date on
     * @return
     */
    public Date getNextDateAfterRecurrence(Date currentDate) {
        if (pattern == Pattern.NONE) {
            return null;
        }
        
        LocalDateTime localDateTime = LocalDateTime.ofInstant(currentDate.toInstant(),
                ZoneId.systemDefault());
        LocalDateTime finalDateTime = localDateTime;

        switch (pattern) {
        case NONE:
            return null;
            
        case DAILY:
            finalDateTime = localDateTime.plusDays(1);
            break;
            
        case WEEKLY:
            finalDateTime = localDateTime.plusWeeks(1);
            break;
            
        case MONTHLY:
            finalDateTime = localDateTime.plusMonths(1);
            break;
            
        case YEARLY:
            finalDateTime = localDateTime.plusYears(1);
            break;
            
        default:
            assert false : "Not possible";
            break;
        }
        
        return Date.from(finalDateTime.atZone(ZoneId.systemDefault()).toInstant());
    }
    
    /**
     * Get the same recurrence, except that we have one less frequency.
     * @return
     * @throws IllegalValueException 
     */
    public Recurrence getRecurrenceWithOneFrequencyLess() throws IllegalValueException {
        if (pattern == Pattern.NONE) {
            return null;
        }
        
        if (frequency == 1) {
            return new Recurrence();
        }
        
        return new Recurrence(pattern, frequency - 1);
    }
}
```
###### \java\teamfour\tasc\model\task\status\EventStatus.java
``` java
package teamfour.tasc.model.task.status;

/**
 * Whether the event has started or not.
 */
public enum EventStatus {
    NOT_AN_EVENT,
    NOT_STARTED,
    IN_PROGRESS,
    ENDED
}
```
###### \java\teamfour\tasc\model\task\Task.java
``` java
    /**
     * Checks whether the recurrence is valid according to 
     * the type of the task.
     * 
     * Pre-condition: Recurrence must NOT be null.
     * 
     * @param recurrence of the task
     */
    private boolean isRecurrenceValid(Recurrence recurrence) { 
        assert recurrence != null;

        if (isFloatingTask() && recurrence.hasRecurrence()) {
            return false;
        }
        
        return true;
    }
```
###### \java\teamfour\tasc\model\task\Task.java
``` java
    @Override
    public Complete getComplete() {
        return complete;
    }

    @Override
    public Deadline getDeadline() {
        return deadline;
    }

    @Override
    public Period getPeriod() {
        return period;
    }

    @Override
    public Recurrence getRecurrence() {
        return recurrence;
    }
}
```
###### \java\teamfour\tasc\model\task\UniqueTaskList.java
``` java
    /**
     * Update the old task with new task details.
     * 
     * @param oldTask that will be updated
     * @param newTask details
     * @throws TaskNotFoundException if the old task cannot be found in the list
     */
    public void updateTask(ReadOnlyTask oldTask, Task newTask) throws TaskNotFoundException {
        int index = internalList.indexOf(oldTask);
        
        if (index == INTERNAL_LIST_INVALID_INDEX) {
            throw new TaskNotFoundException();
        }
        
        internalList.set(index, newTask);
    }
}
```
###### \java\teamfour\tasc\model\task\util\TaskCompleteConverter.java
``` java
package teamfour.tasc.model.task.util;

import java.util.Date;

import teamfour.tasc.commons.exceptions.IllegalValueException;
import teamfour.tasc.model.task.Complete;
import teamfour.tasc.model.task.Deadline;
import teamfour.tasc.model.task.Name;
import teamfour.tasc.model.task.Period;
import teamfour.tasc.model.task.ReadOnlyTask;
import teamfour.tasc.model.task.Recurrence;
import teamfour.tasc.model.task.Task;
import teamfour.tasc.model.task.exceptions.TaskAlreadyCompletedException;

/**
 * Converts a given uncompleted task to a
 * completed task. If the task is a recurrence,
 * then only the first occurrence is completed, and
 * the remaining recurring tasks will be uncompleted.
 */
public class TaskCompleteConverter {
    private final Task completedTask;
    private final Task uncompletedRemainingRecurringTask;
    
    public static final String TASK_NAME_COMPLETED_SUFFIX = "[Completed At %s]";
    
    /**
     * Constructor for converter.
     * @throws IllegalArgumentException if arguments are null
     * @throws IllegalValueException if the task details are invalid
     * @throws TaskAlreadyCompletedException if the task is already marked complete
     */
    public TaskCompleteConverter(ReadOnlyTask uncompletedTask, Date currentTime)
            throws IllegalArgumentException, TaskAlreadyCompletedException, IllegalValueException {
        
        if (uncompletedTask == null) {
            throw new IllegalArgumentException();
        }
        
        if (currentTime == null) {
            throw new IllegalArgumentException();
        }
        
        if (uncompletedTask.getComplete().isCompleted() == true) {
            throw new TaskAlreadyCompletedException();
        }
        
        String completedString = String.format(TASK_NAME_COMPLETED_SUFFIX, currentTime);
        
        this.completedTask = new Task(
                new Name(uncompletedTask.getName().getName() + " " + completedString),
                new Complete(true),
                uncompletedTask.getDeadline(),
                uncompletedTask.getPeriod(),
                new Recurrence(),
                uncompletedTask.getTags());
        
        Recurrence oldRecurrence = uncompletedTask.getRecurrence();
        Recurrence newRecurrence = oldRecurrence.getRecurrenceWithOneFrequencyLess();
        
        if (newRecurrence == null) {
            this.uncompletedRemainingRecurringTask = null;
        } else {
            Deadline newDeadline = uncompletedTask.getDeadline();
            Period newPeriod = uncompletedTask.getPeriod();
            
            if (newDeadline.hasDeadline()) {
                newDeadline = new Deadline(
                        oldRecurrence.getNextDateAfterRecurrence(newDeadline.getDeadline()));
            }
            
            if (newPeriod.hasPeriod()) {
                newPeriod = new Period(
                        oldRecurrence.getNextDateAfterRecurrence(newPeriod.getStartTime()),
                        oldRecurrence.getNextDateAfterRecurrence(newPeriod.getEndTime()));
            }
            
            this.uncompletedRemainingRecurringTask = new Task(uncompletedTask.getName(),
                new Complete(false),
                newDeadline,
                newPeriod,
                newRecurrence,
                uncompletedTask.getTags());
        }
    }
    
    public Task getCompletedTask() {
        return completedTask;
    }
    
    public Task getUncompletedRemainingRecurringTask() {
        return uncompletedRemainingRecurringTask;
    }
}
```
###### \java\teamfour\tasc\model\TaskList.java
``` java
    /**
     * Update the old task with new task details.
     * 
     * @param oldTask that will be updated
     * @param newTask details
     * @throws UniqueTaskList.TaskNotFoundException if the old task cannot be found in the list
     */
    public void updateTask(ReadOnlyTask oldTask, Task newTask) throws UniqueTaskList.TaskNotFoundException {
        tasks.updateTask(oldTask, newTask);
    }
    
```
###### \java\teamfour\tasc\ui\calendar\CalendarAppointmentGroups.java
``` java
package teamfour.tasc.ui.calendar;

import jfxtras.scene.control.agenda.Agenda.AppointmentGroupImpl;

public class CalendarAppointmentGroups {
    public static final AppointmentGroupImpl COMPLETED = new
            AppointmentGroupImpl().withStyleClass("completed");
    public static final AppointmentGroupImpl OVERDUE = new
            AppointmentGroupImpl().withStyleClass("overdue");
    
    public static final AppointmentGroupImpl DEADLINE = new
            AppointmentGroupImpl().withStyleClass("deadline");
    public static final AppointmentGroupImpl PERIOD = new
            AppointmentGroupImpl().withStyleClass("period");
    public static final AppointmentGroupImpl RECURRING = new
            AppointmentGroupImpl().withStyleClass("recurring");
}
```
###### \java\teamfour\tasc\ui\calendar\CalendarReadOnlyAppointment.java
``` java
package teamfour.tasc.ui.calendar;

import java.time.LocalDateTime;
import java.time.temporal.Temporal;
import java.util.Calendar;
import java.util.Date;

import jfxtras.scene.control.agenda.Agenda.Appointment;
import jfxtras.scene.control.agenda.Agenda.AppointmentGroup;
import teamfour.tasc.commons.util.DateUtil;
import teamfour.tasc.model.task.ReadOnlyTask;
import teamfour.tasc.model.task.status.EventStatus;

/**
 * An implementation of the jfxtra's appointment class to display a task in our
 * agendar calendar control.
 */
public class CalendarReadOnlyAppointment implements Appointment {

    protected ReadOnlyTask associatedTask;
    private int associatedIndex;
    
    private static int DEADLINE_FAKE_START_TIME_MAX_ALLOWED_HOUR = 23;
    private static int DEADLINE_FAKE_DURATION_IN_HOURS = 1;

    public CalendarReadOnlyAppointment(ReadOnlyTask associatedTask, int associatedIndex) {
        this.associatedTask = associatedTask;
        this.associatedIndex = associatedIndex;
    }

    /**
     * Do both objects have the same associated task?
     *
     * Obviously they must both be CalendarReadOnlyAppointment. The
     * associatedTask variables must also match
     */
    public boolean hasSameAssociatedTask(Appointment appointment) {
        if (appointment instanceof CalendarReadOnlyAppointment) {
            CalendarReadOnlyAppointment readOnlyAppointment = (CalendarReadOnlyAppointment) appointment;
            return associatedTask.equals(readOnlyAppointment.associatedTask);
        } else {
            return false;
        }
    }

    @Override
    public Boolean isWholeDay() {
        // not supported
        return false;
    }

    @Override
    public void setWholeDay(Boolean b) {
        // do nothing (read-only)
    }

    @Override
    public String getSummary() {
        return getDescription();
    }

    @Override
    public void setSummary(String s) {
        // do nothing (read-only)
    }

    @Override
    public String getDescription() {
        return "(" + associatedIndex + "): " + associatedTask.getName().getName();
    }

    @Override
    public void setDescription(String s) {
        // do nothing (read-only)
    }

    @Override
    public String getLocation() {
        // not supported
        return "";
    }

    @Override
    public void setLocation(String s) {
        // do nothing (read-only)
    }

    @Override
    public AppointmentGroup getAppointmentGroup() {
        Date currentTime = DateUtil.getInstance().getCurrentTime();
        
        if (associatedTask.getComplete().isCompleted()) {
            return CalendarAppointmentGroups.COMPLETED;
        }

        if (associatedTask.getPeriod().hasPeriod()) {
            if (associatedTask.getEventStatus(currentTime) == EventStatus.ENDED) {
                return CalendarAppointmentGroups.COMPLETED;
            }

            return CalendarAppointmentGroups.PERIOD;
        }

        if (associatedTask.getDeadline().hasDeadline()) {
            if (associatedTask.isOverdue(currentTime)) {
                return CalendarAppointmentGroups.OVERDUE;
            }

            return CalendarAppointmentGroups.DEADLINE;
        }

        return null;
    }

    @Override
    public void setAppointmentGroup(AppointmentGroup s) {
        // do nothing (read-only)
    }

    @Override
    public Calendar getStartTime() {
        // not supported (use getLocalStartTime())
        return null;
    }

    @Override
    public void setStartTime(Calendar c) {
        // do nothing (read-only)
    }

    @Override
    public Calendar getEndTime() {
        // not supported (use getLocalEndTime())
        return null;
    }

    @Override
    public void setEndTime(Calendar c) {
        // do nothing (read-only)
    }

    @Override
    public Temporal getStartTemporal() {
        // not supported (use getLocalStartTime())
        return null;
    }

    @Override
    public void setStartTemporal(Temporal t) {
        // do nothing (read-only)
    }

    @Override
    public Temporal getEndTemporal() {
        // not supported (use getLocalEndTime())
        return null;
    }

    @Override
    public void setEndTemporal(Temporal t) {
        // do nothing (read-only)
    }

    @Override
    public LocalDateTime getStartLocalDateTime() {
        if (associatedTask.getDeadline().hasDeadline()) {
            return getProperDeadlineStartTime(associatedTask.getDeadline().getDeadline());
        }

        if (associatedTask.getPeriod().hasPeriod()) {
            return DateUtil.convertToLocalDateTime(associatedTask.getPeriod().getStartTime());
        }

        return null;
    }

    @Override
    public void setStartLocalDateTime(LocalDateTime v) {
        // do nothing (read-only)
    }

    @Override
    public LocalDateTime getEndLocalDateTime() {
        if (associatedTask.getDeadline().hasDeadline()) {
            return getProperDeadlineEndTime(associatedTask.getDeadline().getDeadline());
        }

        if (associatedTask.getPeriod().hasPeriod()) {
            return DateUtil.convertToLocalDateTime(associatedTask.getPeriod().getEndTime());
        }

        return null;
    }

    @Override
    public void setEndLocalDateTime(LocalDateTime v) {
        // do nothing (read-only)
    }
    
    /**
     * Get the "start time" of a deadline.
     * 
     * Since the calendar does not allow start time = end time, 
     * we must invent a start time and end time (one hour later)
     * for it to show up on the calendar.
     * 
     * Also, deadline that falls on 2300 or later are going to disappear
     * since our end time is 1 hour later, so handle that.
     * 
     * @param deadline of the task
     * @return a proper start time for deadline
     */
    protected static LocalDateTime getProperDeadlineStartTime(Date deadline) {
        LocalDateTime result = DateUtil.convertToLocalDateTime(deadline);
        
        result = DateUtil.clampDateTimeWithMaxAllowedHour(result,
                DEADLINE_FAKE_START_TIME_MAX_ALLOWED_HOUR);
        
        return result;
    }
    
    /**
     * Get the "end time" of a deadline.
     * 
     * Since the calendar does not allow start time = end time, 
     * we must invent a start time and end time (one hour later)
     * for it to show up on the calendar.
     * 
     * Also, deadline that falls on 2300 or later are going to disappear
     * since our end time is 1 hour later, so handle that.
     * 
     * @param deadline of the task
     * @return a proper end time for deadline
     */  
    protected static LocalDateTime getProperDeadlineEndTime(Date deadline) {
        LocalDateTime result = getProperDeadlineStartTime(deadline);
        return result.plusHours(DEADLINE_FAKE_DURATION_IN_HOURS);
    }
}
```
###### \java\teamfour\tasc\ui\calendar\CalendarReadOnlyRecurredAppointment.java
``` java
package teamfour.tasc.ui.calendar;

import java.time.LocalDateTime;
import java.util.Date;

import jfxtras.scene.control.agenda.Agenda.AppointmentGroup;
import teamfour.tasc.commons.util.DateUtil;
import teamfour.tasc.model.task.Deadline;
import teamfour.tasc.model.task.Period;
import teamfour.tasc.model.task.ReadOnlyTask;
import teamfour.tasc.model.task.status.EventStatus;

public class CalendarReadOnlyRecurredAppointment extends CalendarReadOnlyAppointment {

    private final Deadline deadlineForOccurrence;
    private final Period periodForOccurence;
    
    public CalendarReadOnlyRecurredAppointment(ReadOnlyTask associatedTask,
            int associatedIndex,
            Deadline deadlineForOccurrence, Period periodForOccurence) {
        super(associatedTask, associatedIndex);

        this.deadlineForOccurrence = deadlineForOccurrence;
        this.periodForOccurence = periodForOccurence;
    }
    
    @Override
    public AppointmentGroup getAppointmentGroup() {
        Date currentTime = DateUtil.getInstance().getCurrentTime();
        
        if (deadlineForOccurrence.hasDeadline() && deadlineForOccurrence.isOverdue(currentTime)) {
            return CalendarAppointmentGroups.OVERDUE;
        }

        if (periodForOccurence.hasPeriod()
                && (periodForOccurence.getEventStatus(currentTime) == EventStatus.ENDED)) {
            return CalendarAppointmentGroups.COMPLETED;
        }
        return CalendarAppointmentGroups.RECURRING;
    }

    @Override
    public LocalDateTime getStartLocalDateTime() {
        if (deadlineForOccurrence.hasDeadline()) {
            return getProperDeadlineStartTime(deadlineForOccurrence.getDeadline());
        }

        if (periodForOccurence.hasPeriod()) {
            return DateUtil.convertToLocalDateTime(periodForOccurence.getStartTime());
        }

        return null;
    }

    @Override
    public LocalDateTime getEndLocalDateTime() {
        if (deadlineForOccurrence.hasDeadline()) {
            return getProperDeadlineEndTime(deadlineForOccurrence.getDeadline());
        }

        if (periodForOccurence.hasPeriod()) {
            return DateUtil.convertToLocalDateTime(periodForOccurence.getEndTime());
        }

        return null;
    }
}
```
###### \java\teamfour\tasc\ui\CalendarPanel.java
``` java
package teamfour.tasc.ui;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.logging.Logger;

import com.google.common.eventbus.Subscribe;

import javafx.scene.Node;
import javafx.scene.layout.AnchorPane;
import javafx.util.Callback;
import jfxtras.internal.scene.control.skin.agenda.AgendaDaySkin;
import jfxtras.internal.scene.control.skin.agenda.AgendaWeekSkin;
import jfxtras.scene.control.agenda.Agenda;
import jfxtras.scene.control.agenda.Agenda.Appointment;
import teamfour.tasc.commons.core.LogsCenter;
import teamfour.tasc.commons.exceptions.IllegalValueException;
import teamfour.tasc.commons.util.FxViewUtil;
import teamfour.tasc.logic.commands.CalendarCommand;
import teamfour.tasc.model.task.Deadline;
import teamfour.tasc.model.task.Period;
import teamfour.tasc.model.task.ReadOnlyTask;
import teamfour.tasc.model.task.Recurrence;
import teamfour.tasc.ui.calendar.CalendarReadOnlyAppointment;
import teamfour.tasc.ui.calendar.CalendarReadOnlyRecurredAppointment;

/**
 * Panel containing a visual overview of the calendar.
 */
public class CalendarPanel extends UiPart {

    private static Logger logger = LogsCenter.getLogger(CalendarPanel.class);
    private static String currentCalendarView = "";
   
    private Agenda agendaView;
    private ReadOnlyTask lastSelectedTask;

    /**
     * Constructor is kept private as {@link #load(AnchorPane)} is the only way to create a CalendarPanel.
     */
    private CalendarPanel() {
        lastSelectedTask = null;
    }
    
    /**
     * Get current calendar view type.
     */
    public static String getCalendarView() {
        return currentCalendarView;
    }
    
    public static CalendarPanel load(AnchorPane placeholder, List<ReadOnlyTask> initialTaskList) {
        logger.info("Initializing calendar view");
        CalendarPanel calendarPanel = new CalendarPanel();
        calendarPanel.setupAgendaView();
        calendarPanel.refreshTasks(initialTaskList);
        
        FxViewUtil.applyAnchorBoundaryParameters(calendarPanel.agendaView, 0.0, 0.0, 0.0, 0.0);
        placeholder.getChildren().add(calendarPanel.agendaView);
        
        return calendarPanel;
    }

    private void setupAgendaView() {
        agendaView = new Agenda();
        
        // forbid any form of editing
        agendaView.setAllowDragging(false);
        agendaView.setAllowResize(false);        
        agendaView.setEditAppointmentCallback(new Callback<Appointment, Void>() {
            @Override
            public Void call(Appointment appointment) {
                // don't show any editing popups at all
                return null;
            }            
        });
        changeView(CalendarCommand.KEYWORD_CALENDAR_VIEW_WEEK);
    }

    @Override
    public void setNode(Node node) {
        // not applicable
    }

    @Override
    public String getFxmlPath() {
        // not applicable (not using fxml for this panel)
        return null;
    }

    /**
     * Free resources used by the calendar.
     */
    public void freeResources() {
        agendaView = null;
    }
    
```
###### \java\teamfour\tasc\ui\CalendarPanel.java
``` java
    /** 
     * Refreshes the calendar using the new task list given.
     */
    @Subscribe
    public void refreshTasks(List<ReadOnlyTask> taskList) {
        agendaView.appointments().clear();
        
        int index = 0;
        
        for (ReadOnlyTask task : taskList) {
            index++; 
            
            if (isDisplayableInCalendar(task)) {
                try {
                    agendaView.appointments().addAll(generateAllAppointmentsForTask(task, index));
                } catch (IllegalValueException ive) {
                    logger.warning("Fail to generate calendar UI for task " + index);
                }
            }
        }
    }

    /**
     * Generates all appointments given a task, taking into
     * consideration any possible recurring.
     * 
     * Pre-condition: The task must be displayable in calendar.
     * 
     * @param task to generate the calendar UI appointment object
     * @throws IllegalValueException if task has an invalid task detail
     */
    private List<Appointment> generateAllAppointmentsForTask(ReadOnlyTask task, int index)
            throws IllegalValueException {
        assert isDisplayableInCalendar(task);
                
        if (!task.getRecurrence().hasRecurrence()) {
            
            List<Appointment> results = new ArrayList<Appointment>();            
            results.add(getFirstAppointment(task, index));
            return results;
            
        } else {
            return getRecurringAppointments(task, index);
        }
    }

    /**
     * Gets the first appointment for this task.
     * 
     * If the task is recurring, only the first instance of the
     * recurrence will be returned as an appointment
     * 
     * If the task is non-recurring, the same task will be 
     * returned as an appointment.
     * 
     * Pre-condition: The task must be displayable in calendar.
     * 
     * @param task to generate the calendar UI appointment object
     * @throws IllegalValueException if task has an invalid task detail
     */
    private CalendarReadOnlyAppointment getFirstAppointment(ReadOnlyTask task, int index) {
        return new CalendarReadOnlyAppointment(task, index);
    }
    
    /**
     * Gets all recurring appointments for this task.
     * 
     * Pre-condition: The task must be displayable in calendar, and 
     * the task must have recurrence.
     * 
     * @param task to generate the calendar UI appointment object
     * @throws IllegalValueException if task has an invalid task detail
     */
    private List<Appointment> getRecurringAppointments(ReadOnlyTask task, int index)
            throws IllegalValueException {    
        assert isDisplayableInCalendar(task);   
        assert task.getRecurrence().hasRecurrence();

        List<Appointment> results = new ArrayList<Appointment>();
        
        results.add(getFirstAppointment(task, index));
        
        Recurrence remainingRecurrence = task.getRecurrence();
        Deadline currentDeadline = task.getDeadline();
        Period currentPeriod = task.getPeriod();
        
        while (remainingRecurrence.hasRecurrence()) {
            currentDeadline = getNextRecurringDeadline(remainingRecurrence, currentDeadline);
            currentPeriod = getNextRecurringPeriod(remainingRecurrence, currentPeriod);            
            remainingRecurrence = remainingRecurrence.getRecurrenceWithOneFrequencyLess();
            
            results.add(new CalendarReadOnlyRecurredAppointment(task, index, currentDeadline, currentPeriod));
        }
        
        return results;
    }

    /**
     * Gets the next period following right after the given period,
     * with reference to the recurring pattern given.

     * @throws IllegalValueException if the new period time is not valid.
     */
    private Period getNextRecurringPeriod(Recurrence recurrence, Period period)
            throws IllegalValueException {

        if (period.hasPeriod()) {
            Date newStartTime = recurrence.getNextDateAfterRecurrence(period.getStartTime());
            Date newEndTime = recurrence.getNextDateAfterRecurrence(period.getEndTime());
            return new Period(newStartTime, newEndTime);
        }

        return period;
    }

    /**
     * Gets the next deadline following right after the given deadline,
     * with reference to the recurring pattern given.
     */
    private Deadline getNextRecurringDeadline(Recurrence recurrence, Deadline deadline) {

        if (deadline.hasDeadline()) {
            return new Deadline(recurrence.getNextDateAfterRecurrence(deadline.getDeadline()));
        }

        return deadline;
    }

    /**
     * Select the particular task in the calendar.
     */
    public void selectTask(ReadOnlyTask taskToSelect) {
        logger.fine("Calendar will handle selectTask()");
        agendaView.selectedAppointments().clear();
        
        CalendarReadOnlyAppointment taskAppointment = new CalendarReadOnlyAppointment(taskToSelect, -1);
        for (Appointment appointment : agendaView.appointments()) {
            if (taskAppointment.hasSameAssociatedTask(appointment)) {
                logger.fine("Calendar found the right task to select!");
                agendaView.setDisplayedLocalDateTime(taskAppointment.getStartLocalDateTime());
                agendaView.selectedAppointments().add(appointment);
                lastSelectedTask = taskToSelect;
                break;
            }
        }
    }
    
    /**
     * Re-selects the last selected task.
     */
    public void selectLastSelectedTask() {
        selectDate(new Date());
        if (lastSelectedTask != null) {
            selectTask(lastSelectedTask);
        }
    }
    
    /**
     * Determine whether the task can be displayed in the calendar. It cannot
     * be displayed if the task has no timings at all.
     */
    private boolean isDisplayableInCalendar(ReadOnlyTask task) {
        return task.getPeriod().hasPeriod() || task.getDeadline().hasDeadline();
    }
}
```
###### \resources\view\DarkTheme.css
``` css
.completed { -fx-background-color: #665f5e; -fx-fill: #665f5e; }
.overdue { -fx-background-color: #ff3004; -fx-fill: #ff3004; }
.deadline { -fx-background-color: #f7ff04; -fx-fill: #f7ff04; }
.period { -fx-background-color: #04ecff; -fx-fill: #04ecff; }
.recurring { -fx-background-color: #04ffd5; -fx-fill: #04ffd5; }

```
###### \resources\view\DarkTheme.css
``` css
.Agenda {
	-fx-font-size: 10pt;
    -fx-font-family: "Segoe UI Semibold";
}
```
###### \resources\view\TaskListCard.fxml
``` fxml
                        <Label fx:id="deadline" styleClass="cell_small_label" text="\$deadline">
                        	<graphic>
                        		<ImageView fitWidth="16.0" fitHeight="16.0">
                        			<image>
                        				<Image url="images/task_deadline.png"/>
                        			</image>
                        		</ImageView>
                        	</graphic>
                        </Label>
                        <Label fx:id="period" styleClass="cell_small_label" text="\$period">                        
                        	<graphic>
                        		<ImageView fitWidth="16.0" fitHeight="16.0">
                        			<image>
                        				<Image url="images/task_period.png"/>
                        			</image>
                        		</ImageView>
                        	</graphic>
                        </Label>
                        <Label fx:id="recurrence" styleClass="cell_small_label" text="\$recurrence">                        
                        	<graphic>
                        		<ImageView fitWidth="16.0" fitHeight="16.0">
                        			<image>
                        				<Image url="images/task_recurrence.png"/>
                        			</image>
                        		</ImageView>
                        	</graphic>
                        </Label>
                        <Label fx:id="tags" styleClass="cell_small_label" text="\$tags">
                        	<graphic>
                        		<ImageView fitWidth="16.0" fitHeight="16.0">
                        			<image>
                        				<Image url="images/task_tags.png"/>
                        			</image>
                        		</ImageView>
                        	</graphic>
                        </Label>                        
```
