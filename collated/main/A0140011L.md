# A0140011L
###### \java\teamfour\tasc\commons\events\ui\TaskPanelListChangedEvent.java
``` java
package teamfour.tasc.commons.events.ui;

import java.util.List;

import teamfour.tasc.commons.events.BaseEvent;
import teamfour.tasc.model.ReadOnlyTaskList;
import teamfour.tasc.model.task.ReadOnlyTask;

/**
 * Represents a content change in the Task List panel.
 */
public class TaskPanelListChangedEvent extends BaseEvent {

    private final List<ReadOnlyTask> newTaskList;

    /**
     * Constructor for event
     * @param newTaskList contents
     */
    public TaskPanelListChangedEvent(List<ReadOnlyTask> newTaskList){
        this.newTaskList = newTaskList;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public List<ReadOnlyTask> getNewTaskList() {
        return newTaskList;
    }
}
```
###### \java\teamfour\tasc\commons\util\DateUtil.java
``` java
package teamfour.tasc.commons.util;

import java.util.Date;

/**
 * Operations related to dates.
 */
public class DateUtil {
    
    /**
     * Get the current date.
     */
    public static Date getCurrentTime() {
        return new Date();
    }
}
```
###### \java\teamfour\tasc\logic\commands\CommandHelper.java
``` java
    /**
     * Convert the date object into a string that the pretty time parser
     * can actually understand.
     *
     * @param date to convert to
     * @return string that can be parsed by pretty time library
     */
    public static String convertDateToPrettyTimeParserFriendlyString(Date date) {
        return String.format("%tb %td %tY %tT", date, date, date, date);
    }
}
```
###### \java\teamfour\tasc\logic\commands\CompleteCommand.java
``` java
package teamfour.tasc.logic.commands;

import teamfour.tasc.commons.core.Messages;
import teamfour.tasc.commons.core.UnmodifiableObservableList;
import teamfour.tasc.commons.exceptions.IllegalValueException;
import teamfour.tasc.commons.util.DateUtil;
import teamfour.tasc.model.keyword.CompleteCommandKeyword;
import teamfour.tasc.model.task.Complete;
import teamfour.tasc.model.task.ReadOnlyTask;
import teamfour.tasc.model.task.Task;
import teamfour.tasc.model.task.UniqueTaskList.DuplicateTaskException;
import teamfour.tasc.model.task.UniqueTaskList.TaskNotFoundException;
import teamfour.tasc.model.task.exceptions.TaskAlreadyCompletedException;
import teamfour.tasc.model.task.util.TaskCompleteConverter;

/**
 * Marks a task as complete using the last displayed index from the task list.
 */
public class CompleteCommand extends Command {

    public static final String COMMAND_WORD = CompleteCommandKeyword.keyword;

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Mark as complete the task identified by the index number used "
            + "in the last task listing.\n" + "Parameters: INDEX (must be a positive integer)\n" + "Example: "
            + COMMAND_WORD + " 1";

    public static final String MESSAGE_COMPLETE_TASK_SUCCESS = "Completed Task: %1$s";
    public static final String MESSAGE_COMPLETE_TASK_UNDO_SUCCESS = "Marked task as uncompleted: %1$s";
    public static final String MESSAGE_COMPLETE_TASK_ALREADY_COMPLETED = "Task is already completed: %1$s";

    public final int targetIndex;

    private ReadOnlyTask oldReadOnlyTask;
    private TaskCompleteConverter newTasks;

    public CompleteCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        oldReadOnlyTask = lastShownList.get(targetIndex - 1);

        try {
            newTasks = new TaskCompleteConverter(oldReadOnlyTask, DateUtil.getCurrentTime());
        } catch (TaskAlreadyCompletedException | IllegalValueException e) {
            return new CommandResult(String.format(MESSAGE_COMPLETE_TASK_ALREADY_COMPLETED,
                    oldReadOnlyTask));
        }

        try {
            model.updateTask(oldReadOnlyTask, newTasks.getCompletedTask());
            
            if (newTasks.getUncompletedRemainingRecurringTask() != null) {
                model.addTask(newTasks.getUncompletedRemainingRecurringTask());
            }
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        } catch (DuplicateTaskException dte) {
            assert false : "Not possible";
        }

        return new CommandResult(
                String.format(MESSAGE_COMPLETE_TASK_SUCCESS, newTasks.getCompletedTask()));
    }

    @Override
    public boolean canUndo() {
        return true;
    }

}
```
###### \java\teamfour\tasc\logic\commands\UpdateCommand.java
``` java
package teamfour.tasc.logic.commands;

import java.util.Date;
import java.util.List;
import java.util.Set;
import java.util.logging.Logger;

import teamfour.tasc.commons.core.LogsCenter;
import teamfour.tasc.commons.core.Messages;
import teamfour.tasc.commons.core.UnmodifiableObservableList;
import teamfour.tasc.commons.exceptions.IllegalValueException;
import teamfour.tasc.commons.util.CollectionUtil;
import teamfour.tasc.logic.LogicManager;
import teamfour.tasc.model.keyword.UpdateCommandKeyword;
import teamfour.tasc.model.tag.Tag;
import teamfour.tasc.model.tag.UniqueTagList;
import teamfour.tasc.model.tag.UniqueTagList.DuplicateTagException;
import teamfour.tasc.model.tag.exceptions.TagNotFoundException;
import teamfour.tasc.model.task.Complete;
import teamfour.tasc.model.task.Deadline;
import teamfour.tasc.model.task.Name;
import teamfour.tasc.model.task.Period;
import teamfour.tasc.model.task.ReadOnlyTask;
import teamfour.tasc.model.task.Recurrence;
import teamfour.tasc.model.task.Task;
import teamfour.tasc.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Updates a task identified using it's last displayed index from the task list.
 */
public class UpdateCommand extends Command {

    public static final String COMMAND_WORD = UpdateCommandKeyword.keyword;

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Updates the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer) [name NAME] [by DEADLINE] "
            + "[from START_TIME to END_TIME] [repeatdeadline FREQUENCY COUNT] "
            + "[repeattime FREQUENCY COUNT] [tag \"TAG\"...]\n" + "Example: " + COMMAND_WORD
            + " 1 by 15 Sep 3pm";

    public static final String MESSAGE_UPDATE_TASK_SUCCESS = "Updated Task: %1$s";
    private static final String MESSAGE_UPDATE_TASK_UNDO_SUCCESS = 
            "Changes to task was reverted. Now: %1$s";
    private static final String MESSAGE_PERIOD_NEED_BOTH_START_AND_END_TIME = 
            "Period needs to have both start and end time.";

    public static final String PREFIX_REMOVE = "remove";

    public static final String KEYWORD_NAME = "name";
    public static final String KEYWORD_DEADLINE = "by";
    public static final String KEYWORD_PERIOD_START_TIME = "from";
    public static final String KEYWORD_PERIOD_END_TIME = "to";
    public static final String KEYWORD_RECURRENCE = "repeat";
    public static final String KEYWORD_TAG = "tag";

    public static final String KEYWORD_REMOVE_DEADLINE = PREFIX_REMOVE + KEYWORD_DEADLINE;
    public static final String KEYWORD_REMOVE_START_TIME = PREFIX_REMOVE
            + KEYWORD_PERIOD_START_TIME;
    public static final String KEYWORD_REMOVE_END_TIME = PREFIX_REMOVE + KEYWORD_PERIOD_END_TIME;
    public static final String KEYWORD_REMOVE_RECURRENCE = PREFIX_REMOVE
            + KEYWORD_RECURRENCE;
    public static final String KEYWORD_REMOVE_TAG = PREFIX_REMOVE + KEYWORD_TAG;

    public static final String[] VALID_KEYWORDS = { COMMAND_WORD, KEYWORD_NAME, KEYWORD_DEADLINE,
            KEYWORD_PERIOD_START_TIME, KEYWORD_PERIOD_END_TIME, KEYWORD_RECURRENCE, KEYWORD_TAG,
            KEYWORD_REMOVE_DEADLINE, KEYWORD_REMOVE_START_TIME, KEYWORD_REMOVE_END_TIME,
            KEYWORD_REMOVE_RECURRENCE, KEYWORD_REMOVE_TAG };

    public final int targetIndex;

    public final String updatedName;
    public final String updatedBy;
    public final String updatedStartTime;
    public final String updatedEndTime;
    public final String updatedRecurrence;
    public final Set<String> tagsToAdd;

    public final boolean removeDeadline;
    public final boolean removePeriod;
    public final boolean removeRecurrence;
    public final Set<String> tagsToRemove;
    
    private final Logger logger = LogsCenter.getLogger(UpdateCommand.class);

    private ReadOnlyTask oldReadOnlyTask;
    private Task newTask;

    /**
     * Constructor for update command, to update the task details of a task.
     * 
     * Note: Parameters can be null, to indicate that no changes were made to
     * that particular detail.
     * 
     * @param targetIndex of the task to update
     */
    public UpdateCommand(int targetIndex, String newName, String newBy, String newStartTime,
            String newEndTime, String newRecurrence, Set<String> newTags, 
            boolean removeDeadline, boolean removePeriod, boolean removeRecurrence,
            Set<String> deleteTags) {
        this.targetIndex = targetIndex;

        this.updatedName = newName;
        this.updatedBy = newBy;
        this.updatedStartTime = newStartTime;
        this.updatedEndTime = newEndTime;
        this.updatedRecurrence = newRecurrence;
        this.tagsToAdd = newTags;

        this.removeDeadline = removeDeadline;
        this.removePeriod = removePeriod;
        this.removeRecurrence = removeRecurrence;
        this.tagsToRemove = deleteTags;
    }

    @Override
    public CommandResult execute() {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        oldReadOnlyTask = lastShownList.get(targetIndex - 1);
        try {
            newTask = updateOldTaskToNewTask(oldReadOnlyTask);
        } catch (IllegalValueException ive) {
            return new CommandResult(ive.getMessage());
        }

        try {
            model.updateTask(oldReadOnlyTask, newTask);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }

        return new CommandResult(String.format(MESSAGE_UPDATE_TASK_SUCCESS, newTask));
    }

    @Override
    public boolean canUndo() {
        return true;
    }

    /**
     * Update the task details of the old task by creating a new task with the
     * new details.
     * 
     * @param oldTask to be updated
     * @return the updated task with the new details
     */
    private Task updateOldTaskToNewTask(ReadOnlyTask oldTask) throws IllegalValueException {
        Name newName = oldTask.getName();
        Complete newComplete = oldTask.getComplete();
        Deadline newDeadline = oldTask.getDeadline();
        Period newPeriod = oldTask.getPeriod();
        Recurrence newRecurrence = oldTask.getRecurrence();
        UniqueTagList newTags = oldTask.getTags();

        // adding new details
        if (this.updatedName != null) {
            newName = new Name(this.updatedName);
        }
        if (this.updatedBy != null) {
            newDeadline = new Deadline(CommandHelper.convertStringToDate(this.updatedBy));
        }
        
        if (this.updatedStartTime != null || this.updatedEndTime != null) {
            if (this.updatedStartTime == null && newPeriod.getStartTime() == null) {
                throw new IllegalValueException(MESSAGE_PERIOD_NEED_BOTH_START_AND_END_TIME);
            }
            if (this.updatedEndTime == null && newPeriod.getEndTime() == null) {
                throw new IllegalValueException(MESSAGE_PERIOD_NEED_BOTH_START_AND_END_TIME);
            }
            
            // TODO magic string
            // TODO SLAP
            // TODO better test this!
            String finalDateString = "";
            int startDateIndex = 0;
            int endDateIndex = 1;
            
            if (this.updatedStartTime != null && this.updatedEndTime != null) {
                finalDateString = this.updatedStartTime + " and " + this.updatedEndTime;
            }
            else if (this.updatedStartTime != null) {
                // must do it the other way round, otherwise Pretty Time will get confused
                finalDateString = CommandHelper.convertDateToPrettyTimeParserFriendlyString(newPeriod.getEndTime()) +
                        " and " + this.updatedStartTime;
                startDateIndex = 1;
                endDateIndex = 0;
            }
            else if (this.updatedEndTime != null) {
                finalDateString = CommandHelper.convertDateToPrettyTimeParserFriendlyString(newPeriod.getStartTime()) +
                        " and " + this.updatedEndTime;
            }
            
            List<Date> finalOutput = CommandHelper.convertStringToMultipleDates(finalDateString);
            
            if (finalOutput.size() == 2) {                    
                newPeriod = new Period(finalOutput.get(startDateIndex), finalOutput.get(endDateIndex));
            } else {
                throw new IllegalValueException(MESSAGE_PERIOD_NEED_BOTH_START_AND_END_TIME);
            }
        }
        
        if (this.updatedRecurrence != null) {
            newRecurrence = CommandHelper.getRecurrence(this.updatedRecurrence);
        }
        
        if (this.tagsToAdd != null) {
            for (String updatedTag : this.tagsToAdd) {
                try {
                    newTags.add(new Tag(updatedTag));
                } catch (DuplicateTagException dte) {
                    // do nothing (it is fine for the user to accidentally add
                    // the same tag)
                }
            }
        }

        // removing new details
        if (this.removeDeadline) {
            newDeadline = new Deadline();
        }
        if (this.removePeriod) {
            newPeriod = new Period();
        }
        if (this.removeRecurrence) {
            newRecurrence = new Recurrence();
        }
        if (this.tagsToRemove != null) {
            for (String tagToRemove : this.tagsToRemove) {
                try {
                    newTags.remove(new Tag(tagToRemove));
                } catch (TagNotFoundException tnfe) {
                    // do nothing
                    // TODO really do nothing?
                }
            }
        }

        return new Task(newName, newComplete, newDeadline, newPeriod, newRecurrence, newTags);
    }
}
```
###### \java\teamfour\tasc\logic\parser\Parser.java
``` java
    /**
     * Parses arguments in the context of the complete task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareComplete(String args) {

        Optional<Integer> index = parseIndex(args);
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, CompleteCommand.MESSAGE_USAGE));
        }

        return new CompleteCommand(index.get());
    }

    /**
     * Parses arguments in the context of the update task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareUpdate(String args) {
        final KeywordParser parser = new KeywordParser(UpdateCommand.VALID_KEYWORDS);
        HashMap<String, String> parsed = parser
                .parseKeywordsWithoutFixedOrder(UpdateCommand.COMMAND_WORD + args);

        Optional<Integer> targetIndex = parseIndex(parsed.get(UpdateCommand.COMMAND_WORD));
        if (!targetIndex.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
        }

        String name = parsed.get(UpdateCommand.KEYWORD_NAME);
        String by = parsed.get(UpdateCommand.KEYWORD_DEADLINE);
        String startTime = parsed.get(UpdateCommand.KEYWORD_PERIOD_START_TIME);
        String endTime = parsed.get(UpdateCommand.KEYWORD_PERIOD_END_TIME);
        String recurrence = parsed.get(UpdateCommand.KEYWORD_RECURRENCE);
        String addTagsArgs = parsed.get(UpdateCommand.KEYWORD_TAG);

        boolean removeDeadline = (parsed.get(UpdateCommand.KEYWORD_REMOVE_DEADLINE) != null);
        boolean removePeriod = (parsed.get(UpdateCommand.KEYWORD_REMOVE_START_TIME) != null
                || parsed.get(UpdateCommand.KEYWORD_REMOVE_END_TIME) != null);
        boolean removeRecurrence = (parsed
                .get(UpdateCommand.KEYWORD_REMOVE_RECURRENCE) != null);
        String removeTagsArgs = parsed.get(UpdateCommand.KEYWORD_REMOVE_TAG);

        Set<String> tagsToAdd = null;
        try {
            if (addTagsArgs != null) {
                tagsToAdd = getTagsFromArgs(addTagsArgs);
            }
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }

        Set<String> tagsToRemove = null;
        try {
            if (removeTagsArgs != null) {
                tagsToRemove = getTagsFromArgs(removeTagsArgs);
            }
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }

        return new UpdateCommand(targetIndex.get(), name, by, startTime, endTime, recurrence,
                tagsToAdd, removeDeadline, removePeriod, removeRecurrence, tagsToRemove);
    }
    
```
###### \java\teamfour\tasc\model\Model.java
``` java
    /** Updates the old task with new task details */
    void updateTask(ReadOnlyTask oldTask, Task newTask) throws TaskNotFoundException;

```
###### \java\teamfour\tasc\model\ModelManager.java
``` java
    @Override
    public synchronized void updateTask(ReadOnlyTask oldTask, Task newTask) throws TaskNotFoundException {
        taskList.updateTask(oldTask, newTask);
        updateFilteredTaskToShowAll();
        indicateTaskListChanged();
    }

```
###### \java\teamfour\tasc\model\task\Complete.java
``` java
package teamfour.tasc.model.task;

import java.util.Objects;

/**
 * Represents a task's completion status in the task list.
 * Guarantees: immutable
 */
public class Complete {
    public static final String TO_STRING_COMPLETED = "Completed";
    public static final String TO_STRING_NOT_COMPLETED = "Not Completed";
    
    private final boolean isCompleted;
    
    /**
     * Constructor for complete status.
     */
    public Complete(boolean isCompleted) {
        this.isCompleted = isCompleted;
    }
    
    @Override
    public String toString() {
        return isCompleted() ? TO_STRING_COMPLETED : TO_STRING_NOT_COMPLETED;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Complete // instanceof handles nulls
                && this.isCompleted() == (((Complete) other).isCompleted())); // state check
    }

    @Override
    public int hashCode() {
        return Objects.hash(isCompleted());
    }

    public boolean isCompleted() {
        return isCompleted;
    }
}
```
###### \java\teamfour\tasc\model\task\Deadline.java
``` java
package teamfour.tasc.model.task;

import java.util.Date;
import java.util.Objects;

import teamfour.tasc.commons.util.ObjectUtil;

/**
 * Represents a task's deadline in the task list.
 * Guarantees: immutable;
 */
public class Deadline {
    public static final String TO_STRING_NO_DEADLINE = "No deadline.";
    
    private final boolean hasDeadline;
    private final Date deadline;
    
    /**
     * Constructor for no deadline.
     */
    public Deadline() {
        this.hasDeadline = false;
        this.deadline = null;
    }
    
    /**
     * Constructor for a given deadline.
     * 
     * Deadline should not be null.
     */
    public Deadline(Date deadline) {
        assert deadline != null;
        
        this.hasDeadline = true;
        this.deadline = deadline;
    }
    
    @Override
    public String toString() {
        if (hasDeadline()) {
            return getDeadline().toString();
        }
        
        return TO_STRING_NO_DEADLINE;
    }

    @Override
    public boolean equals(Object other) {
        if (other == this) { // short circuit if same object
            return true;
        }
        
        if (other instanceof Deadline == false) { // instanceof handles nulls
            return false;
        }
        
        Deadline otherDeadline = (Deadline)other;
        
        return ObjectUtil.isEquivalentOrBothNull(this.hasDeadline(), otherDeadline.hasDeadline()) &&
                ObjectUtil.isEquivalentOrBothNull(this.getDeadline(), otherDeadline.getDeadline()); // state checkk
    }

    @Override
    public int hashCode() {
        return Objects.hash(getDeadline());
    }

    public boolean hasDeadline() {
        return hasDeadline;
    }

    public Date getDeadline() {
        return deadline;
    }
}
```
###### \java\teamfour\tasc\model\task\exceptions\TaskAlreadyCompletedException.java
``` java
package teamfour.tasc.model.task.exceptions;

/**
 * If the task is already completed, but we try to mark it as complete again.
 */
public class TaskAlreadyCompletedException extends Exception {

}
```
###### \java\teamfour\tasc\model\task\Period.java
``` java
package teamfour.tasc.model.task;

import java.util.Date;
import java.util.Objects;

import teamfour.tasc.commons.exceptions.IllegalValueException;
import teamfour.tasc.commons.util.CollectionUtil;
import teamfour.tasc.commons.util.ObjectUtil;

/**
 * Represents a task's period in the task list.
 * (from START_TIME to END_TIME)
 * 
 * Guarantees: immutable;
 */
public class Period {
    public static final String MESSAGE_PERIOD_CONSTRAINTS = "Start time should not be later than end time.";

    public static final String TO_STRING_FORMAT = "%s - %s";
    public static final String TO_STRING_NO_PERIOD = "No period.";
    
    private final boolean hasPeriod;
    private final Date startTime;
    private final Date endTime;
    
    /**
     * Constructor for no period given for task.
     */
    public Period() {
        this.hasPeriod = false;
        this.startTime = null;
        this.endTime = null;
    }
    
    /**
     * Constructor for a given period.
     * 
     * Timings should not be null and
     * period must be valid (see {@link #isValidPeriod(Date, Date)}).
     */
    public Period(Date startTime, Date endTime) throws IllegalValueException {
        assert !CollectionUtil.isAnyNull(startTime, endTime);
        
        if (!isValidPeriod(startTime, endTime)) {
            throw new IllegalValueException(MESSAGE_PERIOD_CONSTRAINTS);
        }
        
        this.hasPeriod = true;
        this.startTime = startTime;
        this.endTime = endTime;
    }

    /**
     * Returns true if given dates are not in the wrong order.
     * (i.e. Start Time < End Time)
     */
    private boolean isValidPeriod(Date startTime, Date endTime) {
        return startTime.before(endTime);
    }

    @Override
    public String toString() {
        if (hasPeriod()) {
            return String.format(TO_STRING_FORMAT, getStartTime(), getEndTime());
        }
        
        return TO_STRING_NO_PERIOD;
    }

    @Override
    public boolean equals(Object other) {
        if (other == this) { // short circuit if same object
            return true;
        }
        
        if (other instanceof Period == false) { // instanceof handles nulls
            return false;
        }
        
        Period otherPeriod = (Period)other;
        
        return ObjectUtil.isEquivalentOrBothNull(this.hasPeriod(), otherPeriod.hasPeriod()) &&
                ObjectUtil.isEquivalentOrBothNull(this.getStartTime(), otherPeriod.getStartTime()) &&
                ObjectUtil.isEquivalentOrBothNull(this.getEndTime(), otherPeriod.getEndTime()); // state check
    }

    @Override
    public int hashCode() {
        return Objects.hash(getStartTime(), getEndTime());
    }

    public boolean hasPeriod() {
        return hasPeriod;
    }

    public Date getStartTime() {
        return startTime;
    }

    public Date getEndTime() {
        return endTime;
    }
}
```
###### \java\teamfour\tasc\model\task\ReadOnlyTask.java
``` java
    /**
     * Is it a floating task?
     */
    default boolean isFloatingTask() {
        return !getDeadline().hasDeadline() && !getPeriod().hasPeriod();
    }
    
    /** 
     * Given the current time, determine whether the task is overdue.
     * (Only make sense if task has a deadline).
     */
    default boolean isOverdue(Date currentTime) {
        if (!getDeadline().hasDeadline()) {
            return false;
        }

        return currentTime.after(getDeadline().getDeadline());
    }
    
    /**
     * Get whether the event has started or not.
     */
    default EventStatus getEventStatus(Date currentTime) {
        if (!getPeriod().hasPeriod()) {
            return EventStatus.NOT_AN_EVENT;
        }
        
        if (currentTime.before(getPeriod().getStartTime())) {
            return EventStatus.NOT_STARTED;
        }
        else if (currentTime.after(getPeriod().getEndTime())) {
            return EventStatus.ENDED;
        }
        
        return EventStatus.IN_PROGRESS;
    }
    
```
###### \java\teamfour\tasc\model\task\Recurrence.java
``` java
package teamfour.tasc.model.task;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Calendar;
import java.util.Date;
import java.util.Objects;

import teamfour.tasc.commons.exceptions.IllegalValueException;
import teamfour.tasc.commons.util.ObjectUtil;

/**
 * Represents a task's recurrence (deadline, period, etc)
 * in the task list.
 * 
 * Guarantees: immutable;
 */
public class Recurrence {
    public enum Pattern {
        NONE, DAILY, WEEKLY, MONTHLY, YEARLY
    }

    public static final String MESSAGE_FREQUENCY_CONSTRAINT = "Frequency must be greater than 0.";
    
    public static final String TO_STRING_FORMAT = "%s [%d time(s)]";
    public static final String TO_STRING_NO_RECURRENCE = "No recurrence.";
    
    private final boolean hasRecurrence;
    private final Pattern pattern;
    private final int frequency;
    
    /**
     * Constructor for no recurrence.
     */
    public Recurrence() {
        this.hasRecurrence = false;
        this.pattern = Pattern.NONE;
        this.frequency = 0;
    }
    
    /**
     * Constructor for a given recurring pattern.
     * 
     * Pattern should not be null and frequency
     * must be valid (see {@link #isValidFrequency(int)}).
     * Pattern should not be NONE, call the default constructor
     * for such patterns.
     */
    public Recurrence(Pattern pattern, int frequency) throws IllegalValueException {
        assert pattern != null;
        assert pattern != Pattern.NONE;
        
        if (!isValidFrequency(frequency)) {
            throw new IllegalValueException(MESSAGE_FREQUENCY_CONSTRAINT);
        }
        
        this.hasRecurrence = true;
        this.pattern = pattern;
        this.frequency = frequency;
    }

    /**
     * Only positive frequency is valid.
     */
    private boolean isValidFrequency(int frequency) {
        return frequency > 0;
    }

    
    @Override
    public String toString() {
        if (hasRecurrence()) {
            return String.format(TO_STRING_FORMAT, getPattern().toString(), getFrequency());
        }
        
        return TO_STRING_NO_RECURRENCE;
    }

    @Override
    public boolean equals(Object other) {
        if (other == this) { // short circuit if same object
            return true;
        }
        
        if (other instanceof Recurrence == false) { // instanceof handles nulls
            return false;
        }
        
        Recurrence otherRecurrence = (Recurrence)other;
        
        return ObjectUtil.isEquivalentOrBothNull(this.hasRecurrence(), otherRecurrence.hasRecurrence()) &&
                ObjectUtil.isEquivalentOrBothNull(this.getPattern(), otherRecurrence.getPattern()) &&
                ObjectUtil.isEquivalentOrBothNull(this.getFrequency(), otherRecurrence.getFrequency()); // state checkk
    
    }

    @Override
    public int hashCode() {
        return Objects.hash(getPattern(), getFrequency());
    }

    public boolean hasRecurrence() {
        return hasRecurrence;
    }

    public Pattern getPattern() {
        return pattern;
    }

    public int getFrequency() {
        return frequency;
    }
    
    /**
     * Get the next recurrence date according to the pattern that
     * we have
     * @param currentDate to base our next date on
     * @return
     */
    public Date getNextDateAfterRecurrence(Date currentDate) {
        if (pattern == Pattern.NONE) {
            return null;
        }
        
        LocalDateTime localDateTime = LocalDateTime.ofInstant(currentDate.toInstant(),
                ZoneId.systemDefault());
        LocalDateTime finalDateTime = localDateTime;

        switch (pattern) {
        case NONE:
            return null;
            
        case DAILY:
            finalDateTime = localDateTime.plusDays(1);
            break;
            
        case WEEKLY:
            finalDateTime = localDateTime.plusWeeks(1);
            break;
            
        case MONTHLY:
            finalDateTime = localDateTime.plusMonths(1);
            break;
            
        case YEARLY:
            finalDateTime = localDateTime.plusYears(1);
            break;
            
        default:
            assert false : "Not possible";
            break;
        }
        
        return Date.from(finalDateTime.atZone(ZoneId.systemDefault()).toInstant());
    }
    
    /**
     * Get the same recurrence, except that we have one less frequency.
     * @return
     * @throws IllegalValueException 
     */
    public Recurrence getRecurrenceWithOneFrequencyLess() throws IllegalValueException {
        if (pattern == Pattern.NONE) {
            return null;
        }
        
        if (frequency == 1) {
            return new Recurrence();
        }
        
        return new Recurrence(pattern, frequency - 1);
    }
}
```
###### \java\teamfour\tasc\model\task\status\EventStatus.java
``` java
package teamfour.tasc.model.task.status;

/**
 * Whether the event has started or not.
 */
public enum EventStatus {
    NOT_AN_EVENT,
    NOT_STARTED,
    IN_PROGRESS,
    ENDED
}
```
###### \java\teamfour\tasc\model\task\Task.java
``` java
    /**
     * Floating task should never have recurrence value.
     * @return
     */
    public static boolean isRecurrenceValid(Deadline deadline, Period period, Recurrence recurrence) {
        assert !CollectionUtil.isAnyNull(deadline, period, recurrence);
        
        boolean floatingTask = !deadline.hasDeadline() && !period.hasPeriod();

        if (floatingTask && recurrence.hasRecurrence()) {
            return false;
        }
        
        return true;
    }
```
###### \java\teamfour\tasc\model\task\Task.java
``` java
    @Override
    public Complete getComplete() {
        return complete;
    }

    @Override
    public Deadline getDeadline() {
        return deadline;
    }

    @Override
    public Period getPeriod() {
        return period;
    }

    @Override
    public Recurrence getRecurrence() {
        return recurrence;
    }
}
```
###### \java\teamfour\tasc\model\task\UniqueTaskList.java
``` java
    /**
     * Update the old task with new task details.
     * 
     * @param oldTask that will be updated
     * @param newTask details
     * @throws TaskNotFoundException if the old task cannot be found in the list
     */
    public void updateTask(ReadOnlyTask oldTask, Task newTask) throws TaskNotFoundException {
        int index = internalList.indexOf(oldTask);
        
        if (index == INTERNAL_LIST_INVALID_INDEX) {
            throw new TaskNotFoundException();
        }
        
        internalList.set(index, newTask);
    }
}
```
###### \java\teamfour\tasc\model\task\util\TaskCompleteConverter.java
``` java
package teamfour.tasc.model.task.util;

import java.util.Date;

import teamfour.tasc.commons.exceptions.IllegalValueException;
import teamfour.tasc.model.task.Complete;
import teamfour.tasc.model.task.Deadline;
import teamfour.tasc.model.task.Name;
import teamfour.tasc.model.task.Period;
import teamfour.tasc.model.task.ReadOnlyTask;
import teamfour.tasc.model.task.Recurrence;
import teamfour.tasc.model.task.Task;
import teamfour.tasc.model.task.exceptions.TaskAlreadyCompletedException;

/**
 * Converts a given uncompleted task to a
 * completed task. If the task is a recurrence,
 * then only the first occurrence is completed, and
 * the remaining recurring tasks will be uncompleted.
 */
public class TaskCompleteConverter {
    private final Task completedTask;
    private final Task uncompletedRemainingRecurringTask;
    
    public static final String TASK_NAME_COMPLETED_SUFFIX = "[Completed At %s]";
    
    /**
     * Constructor for converter.
     * @throws IllegalValueException 
     */
    public TaskCompleteConverter(ReadOnlyTask uncompletedTask, Date currentTime)
            throws IllegalArgumentException, TaskAlreadyCompletedException, IllegalValueException {
        
        if (uncompletedTask == null) {
            throw new IllegalArgumentException();
        }
        
        if (currentTime == null) {
            throw new IllegalArgumentException();
        }
        
        if (uncompletedTask.getComplete().isCompleted() == true) {
            throw new TaskAlreadyCompletedException();
        }
        
        String completedString = String.format(TASK_NAME_COMPLETED_SUFFIX, currentTime);
        
        this.completedTask = new Task(
                new Name(uncompletedTask.getName().getName() + completedString),
                new Complete(true),
                uncompletedTask.getDeadline(),
                uncompletedTask.getPeriod(),
                new Recurrence(),
                uncompletedTask.getTags());
        
        Recurrence oldRecurrence = uncompletedTask.getRecurrence();
        Recurrence newRecurrence = oldRecurrence.getRecurrenceWithOneFrequencyLess();
        
        if (newRecurrence == null) {
            this.uncompletedRemainingRecurringTask = null;
        } else {
            Deadline newDeadline = uncompletedTask.getDeadline();
            Period newPeriod = uncompletedTask.getPeriod();
            
            if (newDeadline.hasDeadline()) {
                newDeadline = new Deadline(
                        oldRecurrence.getNextDateAfterRecurrence(newDeadline.getDeadline()));
            }
            
            if (newPeriod.hasPeriod()) {
                newPeriod = new Period(
                        oldRecurrence.getNextDateAfterRecurrence(newPeriod.getStartTime()),
                        oldRecurrence.getNextDateAfterRecurrence(newPeriod.getEndTime()));
            }
            
            this.uncompletedRemainingRecurringTask = new Task(uncompletedTask.getName(),
                new Complete(false),
                newDeadline,
                newPeriod,
                newRecurrence,
                uncompletedTask.getTags());
        }
    }
    
    public Task getCompletedTask() {
        return completedTask;
    }
    
    public Task getUncompletedRemainingRecurringTask() {
        return uncompletedRemainingRecurringTask;
    }
}
```
###### \java\teamfour\tasc\model\TaskList.java
``` java
    /**
     * Update the old task with new task details.
     * 
     * @param oldTask that will be updated
     * @param newTask details
     * @throws UniqueTaskList.TaskNotFoundException if the old task cannot be found in the list
     */
    public void updateTask(ReadOnlyTask oldTask, Task newTask) throws UniqueTaskList.TaskNotFoundException {
        tasks.updateTask(oldTask, newTask);
    }
    
```
###### \java\teamfour\tasc\ui\calendar\CalendarAppointmentGroups.java
``` java
package teamfour.tasc.ui.calendar;

import jfxtras.scene.control.agenda.Agenda.AppointmentGroupImpl;

public class CalendarAppointmentGroups {
    public static final AppointmentGroupImpl COMPLETED = new
            AppointmentGroupImpl().withStyleClass("completed");
    public static final AppointmentGroupImpl OVERDUE = new
            AppointmentGroupImpl().withStyleClass("overdue");
    
    public static final AppointmentGroupImpl DEADLINE = new
            AppointmentGroupImpl().withStyleClass("deadline");
    public static final AppointmentGroupImpl PERIOD = new
            AppointmentGroupImpl().withStyleClass("period");
    public static final AppointmentGroupImpl RECURRING = new
            AppointmentGroupImpl().withStyleClass("recurring");
}
```
###### \java\teamfour\tasc\ui\calendar\CalendarReadOnlyAppointment.java
``` java
package teamfour.tasc.ui.calendar;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.temporal.Temporal;
import java.util.Calendar;
import java.util.Date;

import jfxtras.scene.control.agenda.Agenda.Appointment;
import jfxtras.scene.control.agenda.Agenda.AppointmentGroup;
import teamfour.tasc.commons.util.DateUtil;
import teamfour.tasc.model.task.ReadOnlyTask;

/**
 * An implementation of the jfxtra's appointment class to
 * display a task in our agendar calendar control.
 */
public class CalendarReadOnlyAppointment implements Appointment {

    protected ReadOnlyTask associatedTask;
    private int associatedIndex;
    
    public CalendarReadOnlyAppointment(ReadOnlyTask associatedTask, int associatedIndex) {
        this.associatedTask = associatedTask;
        this.associatedIndex = associatedIndex;
    }

    /**
     * Do both objects have the same associated task?
     *
     * Obviously they must both be CalendarReadOnlyAppointment. The
     * associatedTask variables must also match
     */
    public boolean hasSameAssociatedTask(Appointment appointment) {
        if (appointment instanceof CalendarReadOnlyAppointment) {
            CalendarReadOnlyAppointment readOnlyAppointment = (CalendarReadOnlyAppointment) appointment;
            return associatedTask.equals(readOnlyAppointment.associatedTask);
        } else {
            return false;
        }
    }

    @Override
    public Boolean isWholeDay() {
        // not supported
        return false;
    }

    @Override
    public void setWholeDay(Boolean b) {
        // do nothing (read-only)
    }

    @Override
    public String getSummary() {
        return getDescription();
    }

    @Override
    public void setSummary(String s) {
        // do nothing (read-only)
    }

    @Override
    public String getDescription() {
        return "(" + associatedIndex + "): " + associatedTask.getName().getName();
    }

    @Override
    public void setDescription(String s) {
        // do nothing (read-only)
    }

    @Override
    public String getLocation() {
        // not supported
        return "";
    }

    @Override
    public void setLocation(String s) {
        // do nothing (read-only)
    }

    @Override
    public AppointmentGroup getAppointmentGroup() {
        if (associatedTask.getComplete().isCompleted()) {
            return CalendarAppointmentGroups.COMPLETED;
        }
        
        if (associatedTask.getPeriod().hasPeriod()) {
            return CalendarAppointmentGroups.PERIOD;
        }
        
        if (associatedTask.getDeadline().hasDeadline()) {
            if (associatedTask.isOverdue(DateUtil.getCurrentTime())) {
                return CalendarAppointmentGroups.OVERDUE;
            }
            
            return CalendarAppointmentGroups.DEADLINE;
        }
        
        return null;
    }

    @Override
    public void setAppointmentGroup(AppointmentGroup s) {
        // do nothing (read-only)
    }

    @Override
    public Calendar getStartTime() {
        // not supported (use getLocalStartTime())
        return null;
    }

    @Override
    public void setStartTime(Calendar c) {
        // do nothing (read-only)
    }

    @Override
    public Calendar getEndTime() {
        // not supported (use getLocalEndTime())
        return null;
    }

    @Override
    public void setEndTime(Calendar c) {
        // do nothing (read-only)
    }

    @Override
    public Temporal getStartTemporal() {
        // not supported (use getLocalStartTime())
        return null;
    }

    @Override
    public void setStartTemporal(Temporal t) {
        // do nothing (read-only)
    }

    @Override
    public Temporal getEndTemporal() {
        // not supported (use getLocalEndTime())
        return null;
    }

    @Override
    public void setEndTemporal(Temporal t) {
        // do nothing (read-only)
    }

    @Override
    public LocalDateTime getStartLocalDateTime() {
        if (associatedTask.getDeadline().hasDeadline()) {
            return convertToLocalDateTime(associatedTask.getDeadline().getDeadline());
        }
        
        if (associatedTask.getPeriod().hasPeriod()) {
            return convertToLocalDateTime(associatedTask.getPeriod().getStartTime());
        }

        return null;
    }

    @Override
    public void setStartLocalDateTime(LocalDateTime v) {
        // do nothing (read-only)
    }

    @Override
    public LocalDateTime getEndLocalDateTime() {
        if (associatedTask.getDeadline().hasDeadline()) {
            return convertToLocalDateTime(associatedTask.getDeadline().getDeadline()).plusHours(1);
        }
        
        if (associatedTask.getPeriod().hasPeriod()) {
            return convertToLocalDateTime(associatedTask.getPeriod().getEndTime());
        }

        return null;
    }

    @Override
    public void setEndLocalDateTime(LocalDateTime v) {
        // do nothing (read-only)
    }

    /**
     * Convert a java.util.Date to a java.time.LocalDateTime
     */
    protected LocalDateTime convertToLocalDateTime(Date date) {
        return date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
    }
}
```
###### \java\teamfour\tasc\ui\calendar\CalendarReadOnlyRecurredAppointment.java
``` java
package teamfour.tasc.ui.calendar;

import java.time.LocalDateTime;

import jfxtras.scene.control.agenda.Agenda.AppointmentGroup;
import teamfour.tasc.commons.util.DateUtil;
import teamfour.tasc.model.task.Deadline;
import teamfour.tasc.model.task.Period;
import teamfour.tasc.model.task.ReadOnlyTask;

public class CalendarReadOnlyRecurredAppointment extends CalendarReadOnlyAppointment {

    private final Deadline deadlineForOccurrence;
    private final Period periodForOccurence;
    
    public CalendarReadOnlyRecurredAppointment(ReadOnlyTask associatedTask,
            int associatedIndex,
            Deadline deadlineForOccurrence, Period periodForOccurence) {
        super(associatedTask, associatedIndex);

        this.deadlineForOccurrence = deadlineForOccurrence;
        this.periodForOccurence = periodForOccurence;
    }
    
    @Override
    public AppointmentGroup getAppointmentGroup() {
        if (associatedTask.getDeadline().hasDeadline()) {
            if (associatedTask.isOverdue(DateUtil.getCurrentTime())) {
                return CalendarAppointmentGroups.OVERDUE;
            }
        }
        
        return CalendarAppointmentGroups.RECURRING;
    }

    @Override
    public LocalDateTime getStartLocalDateTime() {
        if (deadlineForOccurrence.hasDeadline()) {
            return convertToLocalDateTime(deadlineForOccurrence.getDeadline());
        }
        
        if (periodForOccurence.hasPeriod()) {
            return convertToLocalDateTime(periodForOccurence.getStartTime());
        }

        return null;
    }

    @Override
    public LocalDateTime getEndLocalDateTime() {
        if (deadlineForOccurrence.hasDeadline()) {
            return convertToLocalDateTime(deadlineForOccurrence.getDeadline()).plusHours(1);
        }
        
        if (periodForOccurence.hasPeriod()) {
            return convertToLocalDateTime(periodForOccurence.getEndTime());
        }

        return null;
    }
}
```
###### \java\teamfour\tasc\ui\CalendarPanel.java
``` java
package teamfour.tasc.ui;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.logging.Logger;

import com.google.common.eventbus.Subscribe;

import javafx.scene.Node;
import javafx.scene.layout.AnchorPane;
import javafx.util.Callback;
import jfxtras.internal.scene.control.skin.agenda.AgendaDaySkin;
import jfxtras.internal.scene.control.skin.agenda.AgendaWeekSkin;
import jfxtras.scene.control.agenda.Agenda;
import jfxtras.scene.control.agenda.Agenda.Appointment;
import teamfour.tasc.commons.core.LogsCenter;
import teamfour.tasc.commons.exceptions.IllegalValueException;
import teamfour.tasc.commons.util.FxViewUtil;
import teamfour.tasc.logic.commands.CalendarCommand;
import teamfour.tasc.model.task.Deadline;
import teamfour.tasc.model.task.Period;
import teamfour.tasc.model.task.ReadOnlyTask;
import teamfour.tasc.model.task.Recurrence;
import teamfour.tasc.ui.calendar.CalendarReadOnlyAppointment;
import teamfour.tasc.ui.calendar.CalendarReadOnlyRecurredAppointment;

/**
 * Panel containing a visual overview of the calendar.
 */
public class CalendarPanel extends UiPart {

    private static Logger logger = LogsCenter.getLogger(CalendarPanel.class);
    private static String currentCalendarView = "";
   
    private Agenda agendaView;
    private ReadOnlyTask lastSelectedTask;

    /**
     * Constructor is kept private as {@link #load(AnchorPane)} is the only way to create a CalendarPanel.
     */
    private CalendarPanel() {
        lastSelectedTask = null;
    }
    
    /**
     * Get current calendar view type.
     */
    public static String getCalendarView() {
        return currentCalendarView;
    }
    
    public static CalendarPanel load(AnchorPane placeholder, List<ReadOnlyTask> initialTaskList) {
        logger.info("Initializing calendar view");
        CalendarPanel calendarPanel = new CalendarPanel();
        calendarPanel.setupAgendaView();
        calendarPanel.refreshTasks(initialTaskList);
        
        FxViewUtil.applyAnchorBoundaryParameters(calendarPanel.agendaView, 0.0, 0.0, 0.0, 0.0);
        placeholder.getChildren().add(calendarPanel.agendaView);
        
        return calendarPanel;
    }

    private void setupAgendaView() {
        agendaView = new Agenda();
        
        // forbid any form of editing
        agendaView.setAllowDragging(false);
        agendaView.setAllowResize(false);        
        agendaView.setEditAppointmentCallback(new Callback<Appointment, Void>() {
            @Override
            public Void call(Appointment appointment) {
                // don't show any editing popups at all
                return null;
            }            
        });
        changeView(CalendarCommand.KEYWORD_CALENDAR_VIEW_WEEK);
    }

    @Override
    public void setNode(Node node) {
        // not applicable
    }

    @Override
    public String getFxmlPath() {
        // not applicable (not using fxml for this panel)
        return null;
    }

    /**
     * Free resources used by the calendar.
     */
    public void freeResources() {
        // TODO Auto-generated method stub
        agendaView = null;
    }
    
```
###### \java\teamfour\tasc\ui\CalendarPanel.java
``` java
    /** 
     * Refresh the calendar using the new task list given.
     */
    @Subscribe
    public void refreshTasks(List<ReadOnlyTask> taskList) {
        agendaView.appointments().clear();
        
        int index = 0;
        
        for (ReadOnlyTask task : taskList) {
            index++; 
            
            if (isDisplayableInCalendar(task)) {
                try {
                    agendaView.appointments().addAll(generateAppointmentsForTask(task, index));
                } catch (IllegalValueException ive) {
                    assert false: "Not possible";
                }
            }
        }
    }

    /**
     * Generate an appointment(s) given a task, taking into
     * consideration any possible recurring.
     * 
     * Pre-condition: The task must be displayable in calendar.
     * @param task
     * @throws IllegalValueException 
     */
    private List<Appointment> generateAppointmentsForTask(ReadOnlyTask task, int index)
            throws IllegalValueException {
        assert isDisplayableInCalendar(task);
        
        List<Appointment> allAppointments = new ArrayList<Appointment>();
        allAppointments.add(new CalendarReadOnlyAppointment(task, index));
        
        Recurrence taskRecurrence = task.getRecurrence();
        
        if (taskRecurrence.hasRecurrence()) {
            Recurrence remainingRecurrence = task.getRecurrence();
            Deadline currentDeadline = task.getDeadline();
            Period currentPeriod = task.getPeriod();
            
            while (remainingRecurrence.hasRecurrence()) {
                if (currentDeadline.hasDeadline()) {
                    currentDeadline = new Deadline(remainingRecurrence
                            .getNextDateAfterRecurrence(currentDeadline.getDeadline()));
                }

                if (currentPeriod.hasPeriod()) {
                    currentPeriod = new Period(
                            remainingRecurrence
                                    .getNextDateAfterRecurrence(currentPeriod.getStartTime()),
                            remainingRecurrence
                                    .getNextDateAfterRecurrence(currentPeriod.getEndTime()));
                }
                
                remainingRecurrence = remainingRecurrence.getRecurrenceWithOneFrequencyLess();
                
                allAppointments.add(new CalendarReadOnlyRecurredAppointment(task, index, currentDeadline, currentPeriod));
            }
        }
        
        return allAppointments;
    }

    /**
     * Select the particular task in the calendar.
     */
    public void selectTask(ReadOnlyTask taskToSelect) {
        logger.fine("Calendar will handle selectTask()");
        agendaView.selectedAppointments().clear();
        
        CalendarReadOnlyAppointment taskAppointment = new CalendarReadOnlyAppointment(taskToSelect, -1);
        for (Appointment appointment : agendaView.appointments()) {
            if (taskAppointment.hasSameAssociatedTask(appointment)) {
                logger.fine("Calendar found the right task to select!");
                agendaView.setDisplayedLocalDateTime(taskAppointment.getStartLocalDateTime());
                agendaView.selectedAppointments().add(appointment);
                lastSelectedTask = taskToSelect;
                break;
            }
        }
    }
    
    /**
     * Re-selects the last selected task.
     */
    public void selectLastSelectedTask() {
        LocalDateTime time = (new Date()).toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
        agendaView.setDisplayedLocalDateTime(time);
        if (lastSelectedTask != null) {
            selectTask(lastSelectedTask);
        }
    }
    
    /**
     * Determine whether the task can be displayed in the calendar. It cannot
     * be displayed if the task has no timings at all.
     */
    private boolean isDisplayableInCalendar(ReadOnlyTask task) {
        return task.getPeriod().hasPeriod() || task.getDeadline().hasDeadline();
    }
}
```
