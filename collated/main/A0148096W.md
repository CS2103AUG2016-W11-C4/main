# A0148096W
###### \java\teamfour\tasc\commons\events\ui\ChangeCalendarViewRequestEvent.java
``` java

package teamfour.tasc.commons.events.ui;

import teamfour.tasc.commons.events.BaseEvent;

/**
 * An event requesting to change the calendar view.
 */
public class ChangeCalendarViewRequestEvent extends BaseEvent {

    private final String calendarViewType;
    
    public ChangeCalendarViewRequestEvent(String calendarViewType) {
        this.calendarViewType = calendarViewType;
    }
    
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public String getCalendarViewType() {
        return calendarViewType;
    }
}
```
###### \java\teamfour\tasc\commons\events\ui\JumpToCalendarDateRequestEvent.java
``` java

package teamfour.tasc.commons.events.ui;

import java.util.Date;

import teamfour.tasc.commons.events.BaseEvent;

/**
 * An event requesting calendar to jump to date given.
 */
public class JumpToCalendarDateRequestEvent extends BaseEvent {

    private final Date date;
    
    public JumpToCalendarDateRequestEvent(Date date) {
        this.date = date;
    }
    
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public Date getDate() {
        return date;
    }
}
```
###### \java\teamfour\tasc\commons\events\ui\TaskListRenamedEvent.java
``` java

package teamfour.tasc.commons.events.ui;

import teamfour.tasc.commons.events.BaseEvent;

/**
 * Represents that the task list has been renamed
 */
public class TaskListRenamedEvent extends BaseEvent {

    private final String newPath;

    public TaskListRenamedEvent(String newPath) {
        this.newPath = newPath;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public String getNewPath() {
        return newPath;
    }
}
```
###### \java\teamfour\tasc\logic\commands\CalendarCommand.java
``` java

package teamfour.tasc.logic.commands;

import java.util.Date;

import teamfour.tasc.commons.core.EventsCenter;
import teamfour.tasc.commons.events.ui.ChangeCalendarViewRequestEvent;
import teamfour.tasc.commons.events.ui.JumpToCalendarDateRequestEvent;
import teamfour.tasc.commons.exceptions.IllegalValueException;
import teamfour.tasc.logic.keyword.CalendarCommandKeyword;
import teamfour.tasc.logic.keyword.DayKeyword;
import teamfour.tasc.logic.keyword.TodayKeyword;
import teamfour.tasc.logic.keyword.WeekKeyword;
import teamfour.tasc.ui.CalendarPanel;

/**
 * Changes the calendar view.
 */
public class CalendarCommand extends Command {

    public static final String COMMAND_WORD = CalendarCommandKeyword.keyword;

    public static final String KEYWORD_CALENDAR_VIEW_DAY = DayKeyword.keyword;
    public static final String KEYWORD_CALENDAR_VIEW_WEEK = WeekKeyword.keyword;
    public static final String KEYWORD_CALENDAR_VIEW_TODAY = TodayKeyword.keyword;
    
    public static final String MESSAGE_USAGE = COMMAND_WORD 
            + ": Changes the calendar view. "
            + "Parameters: day|week|today\n"
            + "Example: " + COMMAND_WORD + " day";

    public static final String MESSAGE_SUCCESS = 
            "Calendar changed to %1$s view.";
    public static final String MESSAGE_SUCCESS_SELECTED_TODAY = 
            "Calendar is now showing the current time.";
    public static final String MESSAGE_FAILURE_ALREADY_IN_VIEW = 
            "Calendar is already in %1$s view.";

    private final String calendarView;
    private final boolean isViewingToday;
    
    /**
     * Calendar Command
     * Convenience constructor using raw values.
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public CalendarCommand(String calendarView) throws IllegalValueException {
        if (!isCalendarViewValid(calendarView)) {
            throw new IllegalValueException("Invalid calendar view type.");
        }
        this.isViewingToday = calendarView.equals(KEYWORD_CALENDAR_VIEW_TODAY);
        this.calendarView = calendarView;
    }
    
    /**
     * Validates the calendar view String in the argument.
     */
    private boolean isCalendarViewValid(String calendarView) {
        if (calendarView == null) {
            return false;
        }
        return calendarView.equals(KEYWORD_CALENDAR_VIEW_DAY) ||
                calendarView.equals(KEYWORD_CALENDAR_VIEW_WEEK) ||
                calendarView.equals(KEYWORD_CALENDAR_VIEW_TODAY);
    }

    @Override
    public CommandResult execute() {
        if (isViewingToday) {
            EventsCenter.getInstance().post(new JumpToCalendarDateRequestEvent(new Date()));
            return new CommandResult(MESSAGE_SUCCESS_SELECTED_TODAY);
        }
        
        if (calendarView.equals(CalendarPanel.getCalendarView())) {
            return new CommandResult(String.format(MESSAGE_FAILURE_ALREADY_IN_VIEW, calendarView));
        }
        
        EventsCenter.getInstance().post(new ChangeCalendarViewRequestEvent(calendarView));
        return new CommandResult(String.format(MESSAGE_SUCCESS, calendarView));
    }

    @Override
    public boolean canUndo() {
        return false;
    }
}
```
###### \java\teamfour\tasc\logic\commands\CommandHelper.java
``` java
    /**
     * Converts a String to Date if possible, otherwise returns null.
     * @param dateString the String containing the Date which may be null
     * @return the Date from String, or null if not possible
     */
    public static Date tryConvertStringToDateOrReturnNull(String dateString) {
        if (dateString == null) {
            return null;
        }
        try {
            return CommandHelper.convertStringToDate(dateString);
        } catch (IllegalValueException e) {
            logger.warning("Invalid date string in method " +
                        "convertStringToDateIfPossible: " + dateString);
        }
        return null;
    }

    /**
     * Precondition: date argument is not null.
     * Returns a Date object using date with time set to start of day.
     * @param date the Date object
     * @return a Date object set to start of the date
     */
    public static Date getStartOfTheDate(Date date) {
        assert date != null;
        Calendar c = Calendar.getInstance();
        c.setTime(date);
        c.set(Calendar.HOUR_OF_DAY, 0);
        c.set(Calendar.MINUTE, 0);
        c.set(Calendar.SECOND, 0);
        c.set(Calendar.MILLISECOND, 0);
        return c.getTime();
    }

    /**
     * Precondition: date argument is not null.
     * Returns a Date object using date with time set to end of day.
     * @param date the Date object
     * @return a Date object set to end of the date
     */
    public static Date getEndOfTheDate(Date date) {
        assert date != null;
        Calendar c = Calendar.getInstance();
        c.setTime(date);
        c.set(Calendar.HOUR_OF_DAY, 23);
        c.set(Calendar.MINUTE, 59);
        c.set(Calendar.SECOND, 59);
        c.set(Calendar.MILLISECOND, 999);
        return c.getTime();
    }

```
###### \java\teamfour\tasc\logic\commands\HideCommand.java
``` java

package teamfour.tasc.logic.commands;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

import teamfour.tasc.commons.exceptions.IllegalValueException;
import teamfour.tasc.logic.keyword.ByKeyword;
import teamfour.tasc.logic.keyword.FromKeyword;
import teamfour.tasc.logic.keyword.HideCommandKeyword;
import teamfour.tasc.logic.keyword.OnKeyword;
import teamfour.tasc.logic.keyword.TagKeyword;
import teamfour.tasc.logic.keyword.ToKeyword;
import teamfour.tasc.model.task.qualifiers.DeadlineQualifier;
import teamfour.tasc.model.task.qualifiers.EndTimeQualifier;
import teamfour.tasc.model.task.qualifiers.StartTimeQualifier;
import teamfour.tasc.model.task.qualifiers.StartToEndTimeQualifier;
import teamfour.tasc.model.task.qualifiers.TagsQualifier;
import teamfour.tasc.model.task.qualifiers.TypeQualifier;

/**
 * Hides results from current listing results to the user that match the filters.
 */
public class HideCommand extends Command {
    public static final String COMMAND_WORD = HideCommandKeyword.keyword;
    
    public static final String MESSAGE_USAGE = COMMAND_WORD 
            + ": Hides listing results with specified type, date or tags. "
            + "Parameters: [TYPE...] [on DATE] [by DEADLINE] [from START_TIME] "
            + "[to END_TIME] [tag \"TAG\"...]\n"
            + "Example: " + COMMAND_WORD + " events on 24 Sep, tag \"Important\"";
    
    public static final String KEYWORD_DATE = OnKeyword.keyword;
    public static final String KEYWORD_DEADLINE = ByKeyword.keyword;
    public static final String KEYWORD_PERIOD_START_TIME = FromKeyword.keyword;
    public static final String KEYWORD_PERIOD_END_TIME = ToKeyword.keyword;
    public static final String KEYWORD_TAG = TagKeyword.keyword;
    
    public static final String[] VALID_KEYWORDS = { COMMAND_WORD, KEYWORD_DATE,
            KEYWORD_DEADLINE, KEYWORD_PERIOD_START_TIME, KEYWORD_PERIOD_END_TIME, KEYWORD_TAG };

    private final String type;
    private final Date deadline;
    private final Date startTime;
    private final Date endTime;
    private final Set<String> tags;
    private final boolean hasDate;
    
    /**
     * Show Command
     * Convenience constructor using raw values.
     * Set any parameter as null if it is not required.
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public HideCommand(String type, String date, String deadline, String startTime, 
                        String endTime, Set<String> tags) throws IllegalValueException {
        
        this.deadline = CommandHelper.tryConvertStringToDateOrReturnNull(deadline);
        
        Date convertedDate = CommandHelper.tryConvertStringToDateOrReturnNull(date);
        if (convertedDate != null) {
            hasDate = true;
            this.startTime = CommandHelper.getStartOfTheDate(convertedDate);
            this.endTime = CommandHelper.getEndOfTheDate(convertedDate);
        } else {
            hasDate = false;
            this.startTime = CommandHelper.tryConvertStringToDateOrReturnNull(startTime);
            this.endTime = CommandHelper.tryConvertStringToDateOrReturnNull(endTime);
        }
        
        this.tags = new HashSet<String>(tags);
        this.type = type;
    }
    
    /**
     * Precondition: model is not null.
     * Adds the filters in this command to the model. 
     * Does not update the list yet.
     */
    private void addCommandFiltersToModel() {
        assert model != null;
        
        if (type != null) {
            model.addTaskListFilter(new TypeQualifier(type), true);
        }
        if (deadline != null) {
            model.addTaskListFilter(new DeadlineQualifier(deadline), true);
        }
        if (hasDate) {
            model.addTaskListFilter(new StartToEndTimeQualifier(startTime, endTime), true);
        }
        if (!hasDate && startTime != null) {
            model.addTaskListFilter(new StartTimeQualifier(startTime), true);
        }
        if (!hasDate && endTime != null) {
            model.addTaskListFilter(new EndTimeQualifier(endTime), true);
        }
        if (!tags.isEmpty()) {
            model.addTaskListFilter(new TagsQualifier(tags), true);
        }
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        
        addCommandFiltersToModel();
        model.updateFilteredTaskListByFilters();
        
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }

    @Override
    public boolean canUndo() {
        return false;
    }

}
```
###### \java\teamfour\tasc\logic\commands\ListCommand.java
``` java

package teamfour.tasc.logic.commands;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

import teamfour.tasc.commons.exceptions.IllegalValueException;
import teamfour.tasc.logic.keyword.ByKeyword;
import teamfour.tasc.logic.keyword.FromKeyword;
import teamfour.tasc.logic.keyword.ListCommandKeyword;
import teamfour.tasc.logic.keyword.SortKeyword;
import teamfour.tasc.logic.keyword.TagKeyword;
import teamfour.tasc.logic.keyword.ToKeyword;
import teamfour.tasc.model.Model;
import teamfour.tasc.model.task.qualifiers.DeadlineQualifier;
import teamfour.tasc.model.task.qualifiers.EndTimeQualifier;
import teamfour.tasc.model.task.qualifiers.StartTimeQualifier;
import teamfour.tasc.model.task.qualifiers.TagsQualifier;
import teamfour.tasc.model.task.qualifiers.TypeQualifier;

/**
 * Lists all tasks in the task list to the user with filters and sort.
 */
public class ListCommand extends Command {
    
    public static final String COMMAND_WORD = ListCommandKeyword.keyword;

    public static final String MESSAGE_USAGE = COMMAND_WORD 
            + ": List all tasks/events with filters. "
            + "Parameters: [TYPE...] [by DEADLINE] [from START_TIME] "
            + "[to END_TIME] [tag \"TAG\"...] [sort SORTING_ORDER]\n"
            + "Example: " + COMMAND_WORD
            + " completed tasks, tag \"Important\", sort earliest first";

    public static final String KEYWORD_DEADLINE = ByKeyword.keyword;
    public static final String KEYWORD_PERIOD_START_TIME = FromKeyword.keyword;
    public static final String KEYWORD_PERIOD_END_TIME = ToKeyword.keyword;
    public static final String KEYWORD_TAG = TagKeyword.keyword;
    public static final String KEYWORD_SORT = SortKeyword.keyword;

    public static final String[] VALID_KEYWORDS = { COMMAND_WORD, KEYWORD_DEADLINE,
            KEYWORD_PERIOD_START_TIME, KEYWORD_PERIOD_END_TIME, KEYWORD_TAG, KEYWORD_SORT };

    private final String type;
    private final Date deadline;
    private final Date startTime;
    private final Date endTime;
    private final Set<String> tags;
    private final String sortOrder;

    /**
     * List Command with default values
     * Lists all uncompleted tasks and events from now.
     */
    public ListCommand() throws IllegalValueException {
        this(Model.FILTER_TYPE_DEFAULT, null, null, null, 
                new HashSet<String>(), Model.SORT_ORDER_DEFAULT);
    }
    
    /**
     * List Command
     * Convenience constructor using raw values.
     * Set any parameter as null if it is not required.
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public ListCommand(String type, String deadline, String startTime, String endTime,
                        Set<String> tags, String sortingOrder) throws IllegalValueException {
        
        this.deadline = CommandHelper.tryConvertStringToDateOrReturnNull(deadline);
        this.startTime = CommandHelper.tryConvertStringToDateOrReturnNull(startTime);
        this.endTime = CommandHelper.tryConvertStringToDateOrReturnNull(endTime);
        this.tags = new HashSet<String>(tags);
        this.type = type;
        this.sortOrder = sortingOrder;
    }

    /**
     * Precondition: model is not null.
     * Resets the filters in this command to filters in the model.
     * Does not update the list yet.
     */
    private void addCommandFiltersToModel() {
        assert model != null;
        if (type != null) {
            model.addTaskListFilter(new TypeQualifier(type), false);
        }
        if (deadline != null) {
            model.addTaskListFilter(new DeadlineQualifier(deadline), false);
        }
        if (startTime != null) {
            model.addTaskListFilter(new StartTimeQualifier(startTime), false);
        }
        if (endTime != null) {
            model.addTaskListFilter(new EndTimeQualifier(endTime), false);
        }
        if (!tags.isEmpty()) {
            model.addTaskListFilter(new TagsQualifier(tags), false);
        }
    }
    
    /**
     * Precondition: model is not null.
     */
    private void filterTaskList() {
        assert model != null;
        model.resetTaskListFilter();
        addCommandFiltersToModel();
        model.updateFilteredTaskListByFilters();
    }

    /**
     * Precondition: model is not null.
     */
    private void sortTaskList() {
        assert model != null;
        if (sortOrder != null) {
            model.sortFilteredTaskList(sortOrder);
        }
    }
    
    @Override
    public CommandResult execute() {
        assert model != null;

        filterTaskList();
        sortTaskList();

        return new CommandResult(
                getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }

    @Override
    public boolean canUndo() {
        return false;
    }

}
```
###### \java\teamfour\tasc\logic\commands\ShowCommand.java
``` java

package teamfour.tasc.logic.commands;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

import teamfour.tasc.commons.exceptions.IllegalValueException;
import teamfour.tasc.logic.keyword.ByKeyword;
import teamfour.tasc.logic.keyword.FromKeyword;
import teamfour.tasc.logic.keyword.OnKeyword;
import teamfour.tasc.logic.keyword.ShowCommandKeyword;
import teamfour.tasc.logic.keyword.TagKeyword;
import teamfour.tasc.logic.keyword.ToKeyword;
import teamfour.tasc.model.task.qualifiers.DeadlineQualifier;
import teamfour.tasc.model.task.qualifiers.EndTimeQualifier;
import teamfour.tasc.model.task.qualifiers.StartTimeQualifier;
import teamfour.tasc.model.task.qualifiers.StartToEndTimeQualifier;
import teamfour.tasc.model.task.qualifiers.TagsQualifier;
import teamfour.tasc.model.task.qualifiers.TypeQualifier;

/**
 * Shows results from current listing results to the user that match the filters.
 */
public class ShowCommand extends Command {
    public static final String COMMAND_WORD = ShowCommandKeyword.keyword;
    
    public static final String MESSAGE_USAGE = COMMAND_WORD 
            + ": Shows only listing results with specified type, date or tags. "
            + "Parameters: [TYPE...] [on DATE] [by DEADLINE] [from START_TIME] "
            + "[to END_TIME] [tag \"TAG\"...]\n"
            + "Example: " + COMMAND_WORD + " events on 24 Sep, tag \"Important\"";

    public static final String KEYWORD_DATE = OnKeyword.keyword;
    public static final String KEYWORD_DEADLINE = ByKeyword.keyword;
    public static final String KEYWORD_PERIOD_START_TIME = FromKeyword.keyword;
    public static final String KEYWORD_PERIOD_END_TIME = ToKeyword.keyword;
    public static final String KEYWORD_TAG = TagKeyword.keyword;
    
    public static final String[] VALID_KEYWORDS = { COMMAND_WORD, KEYWORD_DATE,
            KEYWORD_DEADLINE, KEYWORD_PERIOD_START_TIME, KEYWORD_PERIOD_END_TIME, KEYWORD_TAG };

    private final String type;
    private final Date deadline;
    private final Date startTime;
    private final Date endTime;
    private final Set<String> tags;
    private final boolean hasDate;
    
    /**
     * Show Command
     * Convenience constructor using raw values.
     * Set any parameter as null if it is not required.
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public ShowCommand(String type, String date, String deadline, String startTime, 
                        String endTime, Set<String> tags) throws IllegalValueException {
        
        this.deadline = CommandHelper.tryConvertStringToDateOrReturnNull(deadline);
        
        Date convertedDate = CommandHelper.tryConvertStringToDateOrReturnNull(date);
        if (convertedDate != null) {
            hasDate = true;
            this.startTime = CommandHelper.getStartOfTheDate(convertedDate);
            this.endTime = CommandHelper.getEndOfTheDate(convertedDate);
        } else {
            hasDate = false;
            this.startTime = CommandHelper.tryConvertStringToDateOrReturnNull(startTime);
            this.endTime = CommandHelper.tryConvertStringToDateOrReturnNull(endTime);
        }
        
        this.tags = new HashSet<String>(tags);
        this.type = type;
    }
    
    /**
     * Precondition: model is not null.
     * Adds the filters in this command to the model. 
     * Does not update the list yet.
     */
    private void addCommandFiltersToModel() {
        assert model != null;
        
        if (type != null) {
            model.addTaskListFilter(new TypeQualifier(type), false);
        }
        if (deadline != null) {
            model.addTaskListFilter(new DeadlineQualifier(deadline), false);
        }
        if (hasDate) {
            model.addTaskListFilter(new StartToEndTimeQualifier(startTime, endTime), false);
        }
        if (!hasDate && startTime != null) {
            model.addTaskListFilter(new StartTimeQualifier(startTime), false);
        }
        if (!hasDate && endTime != null) {
            model.addTaskListFilter(new EndTimeQualifier(endTime), false);
        }
        if (!tags.isEmpty()) {
            model.addTaskListFilter(new TagsQualifier(tags), false);
        }
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        
        addCommandFiltersToModel();
        model.updateFilteredTaskListByFilters();
        
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }

    @Override
    public boolean canUndo() {
        return false;
    }

}
```
###### \java\teamfour\tasc\logic\commands\UndoCommand.java
``` java

package teamfour.tasc.logic.commands;

import teamfour.tasc.commons.exceptions.IllegalValueException;
import teamfour.tasc.logic.keyword.UndoCommandKeyword;

/**
 * Undo the last (n) commands.
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = UndoCommandKeyword.keyword;

    public static final String MESSAGE_USAGE = COMMAND_WORD 
            + ": Undo the last command(s). "
            + "Parameters: [Number of steps]\n"
            + "Example: " + COMMAND_WORD + " 5";

    public static final String MESSAGE_SUCCESS = "Last %1$s undone.";
    public static final String MESSAGE_NO_PAST_COMMAND_TO_UNDO = 
            "There is no past command to undo.";

    private final int numCommandsToBeUndone;
    
    /**
     * Default behavior of UndoCommand, undoes 1 command
     */
    public UndoCommand() throws IllegalValueException {
        this(1);
    }

    /**
     * Add Command for floating tasks
     * Convenience constructor using raw values.
     * @throws IllegalValueException if numCommandsToBeUndone is < 1
     */
    public UndoCommand(int numCommandsToBeUndone) throws IllegalValueException {
        if (numCommandsToBeUndone < 1) {
            throw new IllegalValueException("Number of undo must be positive.");
        }
        this.numCommandsToBeUndone = numCommandsToBeUndone;
    }
    
    private String createUndoResultMessage(int numUndone) {
        String resultMessage = MESSAGE_NO_PAST_COMMAND_TO_UNDO;
        if (numUndone == 1) {
            resultMessage = String.format(MESSAGE_SUCCESS, "command");
        } else if (numUndone > 1) {
            resultMessage = String.format(MESSAGE_SUCCESS, numUndone + " commands");
        }
        return resultMessage;
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        
        int numUndone = model.undoTaskListHistory(numCommandsToBeUndone);
        String resultMessage = createUndoResultMessage(numUndone);
        return new CommandResult(resultMessage);
    }

    @Override
    public boolean canUndo() {
        return false;
    }

}
```
###### \java\teamfour\tasc\logic\parser\Parser.java
``` java
    /**
     * Returns null if string is null or empty,
     * else returns the string.
     */
    private String setToNullIfIsEmptyString(String string) {
        if (string == null || string.isEmpty()) {
            return null;
        }
        return string;
    }

    /**
     * Returns empty string if argument is null,
     * otherwise returns the formatted string of tags for proper parsing properly.
     */
    private String formatTagString(String tags) {
        String tagStringResult;

        if (tags == null) {
            tagStringResult = "";
        } else {
            tagStringResult = removeFullStopsAndCommas(tags);
        }
        return tagStringResult;
    }

    /**
     * Precondition: argument is not null.
     * Takes in a string and remove all occurrences of full stops and commas.
     */
    private String removeFullStopsAndCommas(String string) {
        assert string != null;
        String resultString = string.replace(",", "");
        resultString = resultString.replace(".", "");
        return resultString;
    }

    /**
     * Precondition: argument string is not null.
     * Parses the command string in the context of the list task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareList(String args){
        assert args != null;

        // No arguments, use default 'list' command
        if (args.trim().isEmpty()) {
            try {
                return new ListCommand();
            } catch (IllegalValueException ive) {
                return new IncorrectCommand(ive.getMessage());
            }
        }

        final KeywordParser parser = new KeywordParser(ListCommand.VALID_KEYWORDS);
        HashMap<String, String> parsed = parser.parseKeywordsWithoutFixedOrder(ListCommand.COMMAND_WORD + args);
        String type = setToNullIfIsEmptyString(parsed.get(ListCommand.COMMAND_WORD));
        String deadline = setToNullIfIsEmptyString(parsed.get(ListCommand.KEYWORD_DEADLINE));
        String startTime = setToNullIfIsEmptyString(parsed.get(ListCommand.KEYWORD_PERIOD_START_TIME));
        String endTime = setToNullIfIsEmptyString(parsed.get(ListCommand.KEYWORD_PERIOD_END_TIME));
        String tags = setToNullIfIsEmptyString(parsed.get(ListCommand.KEYWORD_TAG));
        String sortingOrder = setToNullIfIsEmptyString(parsed.get(ListCommand.KEYWORD_SORT));

        tags = formatTagString(tags);
        if (sortingOrder != null) {
            sortingOrder = removeFullStopsAndCommas(sortingOrder);
        }

        try {
            return new ListCommand(
                    type,
                    deadline,
                    startTime,
                    endTime,
                    getTagsFromArgs(tags),
                    sortingOrder
            );
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /**
     * Precondition: argument string is not null.
     * Parses the command string in the context of the show command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareShow(String args){
        assert args != null;

        if (args.trim().isEmpty()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, ShowCommand.MESSAGE_USAGE));
        }

        final KeywordParser parser = new KeywordParser(ShowCommand.VALID_KEYWORDS);
        HashMap<String, String> parsed = parser.parseKeywordsWithoutFixedOrder(ShowCommand.COMMAND_WORD + args);
        String type = setToNullIfIsEmptyString(parsed.get(ShowCommand.COMMAND_WORD));
        String date = setToNullIfIsEmptyString(parsed.get(ShowCommand.KEYWORD_DATE));
        String deadline = setToNullIfIsEmptyString(parsed.get(ShowCommand.KEYWORD_DEADLINE));
        String startTime = setToNullIfIsEmptyString(parsed.get(ShowCommand.KEYWORD_PERIOD_START_TIME));
        String endTime = setToNullIfIsEmptyString(parsed.get(ShowCommand.KEYWORD_PERIOD_END_TIME));
        String tags = setToNullIfIsEmptyString(parsed.get(ShowCommand.KEYWORD_TAG));

        tags = formatTagString(tags);

        try {
            return new ShowCommand(
                    type,
                    date,
                    deadline,
                    startTime,
                    endTime,
                    getTagsFromArgs(tags)
            );
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /**
     * Precondition: argument string is not null.
     * Parses the command string in the context of the hide command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareHide(String args){
        assert args != null;

        if (args.trim().isEmpty()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, HideCommand.MESSAGE_USAGE));
        }

        final KeywordParser parser = new KeywordParser(HideCommand.VALID_KEYWORDS);
        HashMap<String, String> parsed = parser.parseKeywordsWithoutFixedOrder(HideCommand.COMMAND_WORD + args);
        String type = setToNullIfIsEmptyString(parsed.get(HideCommand.COMMAND_WORD));
        String date = setToNullIfIsEmptyString(parsed.get(HideCommand.KEYWORD_DATE));
        String deadline = setToNullIfIsEmptyString(parsed.get(HideCommand.KEYWORD_DEADLINE));
        String startTime = setToNullIfIsEmptyString(parsed.get(HideCommand.KEYWORD_PERIOD_START_TIME));
        String endTime = setToNullIfIsEmptyString(parsed.get(HideCommand.KEYWORD_PERIOD_END_TIME));
        String tags = setToNullIfIsEmptyString(parsed.get(HideCommand.KEYWORD_TAG));

        tags = formatTagString(tags);

        try {
            return new HideCommand(
                    type,
                    date,
                    deadline,
                    startTime,
                    endTime,
                    getTagsFromArgs(tags)
            );
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

```
###### \java\teamfour\tasc\logic\parser\Parser.java
``` java
    /**
     * Parses arguments in the context of the change calendar view command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareCalendar(String args) {
        if (args.trim().isEmpty()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, CalendarCommand.MESSAGE_USAGE));
        }
        try {
            return new CalendarCommand(args.trim());
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, CalendarCommand.MESSAGE_USAGE));
        }
    }

```
###### \java\teamfour\tasc\logic\parser\Parser.java
``` java
    /**
     * Parses arguments in the context of the undo command.
     * Special case: if no arg is provided, undoes 1 command.
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareUndo(String args) {
        if (args.trim().isEmpty()) {
            try {
                return new UndoCommand();
            } catch (IllegalValueException ive) {
                return new IncorrectCommand(
                        String.format(MESSAGE_INVALID_COMMAND_FORMAT, UndoCommand.MESSAGE_USAGE));
            }
        }

        Optional<Integer> index = parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, UndoCommand.MESSAGE_USAGE));
        }

        try {
            return new UndoCommand(index.get());
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, UndoCommand.MESSAGE_USAGE));
        }
    }

```
###### \java\teamfour\tasc\model\history\HistoryItem.java
``` java

package teamfour.tasc.model.history;

/**
 * Objects of each class which implements this interface can be reverted to past states.
 * Must be able to be create deep copies of itself.
 * 
 * @param <T> The class of the item
 */
public interface HistoryItem<T> {
    /** creates the state of this object itself as a deep copy */
    T createStateAsDeepCopy();
}
```
###### \java\teamfour\tasc\model\history\HistoryStack.java
``` java

package teamfour.tasc.model.history;

import java.util.LinkedList;

/**
 * Stores and retrieves HistoryItems as a stack.
 * Automatically removes older items when max limit is reached.
 */
public class HistoryStack<T extends HistoryItem<T>> {
    
    private static final int DEFAULT_MAX_NUM_OF_STATES = 10;
    private final int maxNumOfStates;
    
    // Uses a LinkedList so that can removeFirst 
    // for states that are too old.
    private final LinkedList<T> historyLL;
    
    /** Exception thrown when trying to pop an empty HistoryStack */
    public static class OutOfHistoryException extends Exception {
        protected OutOfHistoryException() {
            super("This history queue is empty.");
        }
    }
    
    /**
     * Default constructor creates with default size.
     */
    public HistoryStack() {
        this(DEFAULT_MAX_NUM_OF_STATES);
    }
    
    /**
     * Precondition: maxNumOfStates is > 0.
     * Creates HistoryStack which can store up to
     * a number of history item states.
     * 
     * @param maxNumOfStates max number of history states
     */
    public HistoryStack(int maxNumOfStates) {
        assert maxNumOfStates > 0;
        this.maxNumOfStates = maxNumOfStates;
        historyLL = new LinkedList<T>();
    }
    
    /**
     * Precondition: item passed in argument is not null.
     * Pushes the object to be saved as a history state,
     * by adding its deep copy into this stack.
     * 
     * @param item Object to be saved
     */
    public void push(T item) {
        assert item != null;
        
        if (historyLL.size() >= maxNumOfStates) {
            historyLL.removeFirst();
        }
        historyLL.addLast(item.createStateAsDeepCopy());
    }
    
    /**
     * Pops and returns the latest history item stored.
     * 
     * @return The HistoryItem object
     * @throws OutOfHistoryException if the history queue is empty
     */
    public T pop() throws OutOfHistoryException {
        if (historyLL.size() <= 0) {
            throw new OutOfHistoryException();
        }
        
        return historyLL.removeLast();
    }
    
}
```
###### \java\teamfour\tasc\model\Model.java
``` java
    public static final String SORT_ORDER_BY_EARLIEST_FIRST = "earliest first";
    public static final String SORT_ORDER_BY_LATEST_FIRST = "latest first";
    public static final String SORT_ORDER_BY_A_TO_Z = "a-z";
    public static final String SORT_ORDER_BY_Z_TO_A = "z-a";
    public static final String SORT_ORDER_DEFAULT = SORT_ORDER_BY_EARLIEST_FIRST;
    public static final String FILTER_TYPE_DEFAULT = "uncompleted";

```
###### \java\teamfour\tasc\model\Model.java
``` java
    /** Saves the current state of the TaskList into history */
    void saveTaskListHistory();
    
    /**
     * Precondition: numToUndo must be > 0.
     * Reverts the task list to the most recent past state
     * @return number of history states undone
     */
    int undoTaskListHistory(int numToUndo);
    
```
###### \java\teamfour\tasc\model\Model.java
``` java
    /** Removes all filters of the filtered task list */
    void resetTaskListFilter();
    
    /**
     * Precondition: qualifier is not null.
     * Adds the filter of the filtered task list by the qualifier
     */
    void addTaskListFilter(Qualifier qualifier, boolean negated);

    /** Updates the filtered task list by the added filters */
    void updateFilteredTaskListByFilters();

    /**
     * Precondition: arguments are not null.
     * Sorts the filtered task list by the given sorting order
     */
    void sortFilteredTaskList(String sortOrder);

```
###### \java\teamfour\tasc\model\ModelManager.java
``` java
    @Override
    public void saveTaskListHistory() {
        undoTaskListHistory.push(taskList);
    }

    @Override
    public int undoTaskListHistory(int numToUndo) {
        assert numToUndo > 0;

        int numUndone = 0;
        TaskList historyTaskList = null;
        try {
            for (int i = 0; i < numToUndo; i++) {
                TaskList redoTaskList = historyTaskList;
                if (redoTaskList == null) {
                    redoTaskList = taskList;
                }
                
                historyTaskList = undoTaskListHistory.pop();
                redoTaskListHistory.push(redoTaskList);
                numUndone++;
            }
        } catch (OutOfHistoryException e) {
            logger.fine(e.getMessage());
        }

        if (historyTaskList != null) {
            resetData(historyTaskList);
        }
        return numUndone;
    }

```
###### \java\teamfour\tasc\model\ModelManager.java
``` java
    @Override
    public void resetTaskListFilter() {
        taskListFilter = null;
    }
    
    @Override
    public void addTaskListFilter(Qualifier qualifier, boolean negated) {
        assert qualifier != null;
        
        if (taskListFilter == null) {
            taskListFilter = new PredicateExpression(qualifier, negated);
        } else {
            taskListFilter.addNext(new PredicateExpression(qualifier, negated));
        }
    }

    @Override
    public void updateFilteredTaskListByFilters() {
        updateFilteredTaskList(taskListFilter);
    }
    
    @Override
    public void sortFilteredTaskList(String sortOrder) {
        assert sortOrder != null;
        switch(sortOrder) {
        case Model.SORT_ORDER_BY_EARLIEST_FIRST:
            taskList.sortUsingComparator(new EarliestFirstComparator());
            break;
        case Model.SORT_ORDER_BY_LATEST_FIRST:
            taskList.sortUsingComparator(new LatestFirstComparator());
            break;
        case Model.SORT_ORDER_BY_A_TO_Z:
            taskList.sortUsingComparator(new AToZComparator());
            break;
        case Model.SORT_ORDER_BY_Z_TO_A:
            taskList.sortUsingComparator(new ZToAComparator());
            break;
        default:
            logger.warning("Unable to sort task list due to "
                    + "unrecognized sort order string: " + sortOrder);
            break;
        }
    }

    private void updateFilteredTaskList(Expression expression) {
        if (expression == null) {
            filteredTasks.setPredicate(null);
        } else {
            filteredTasks.setPredicate(expression::satisfies);
        }
    }

    
    //========== Inner classes/interfaces used for filtering ==================================================

    interface Expression {
        boolean satisfies(ReadOnlyTask task);
        String toString();
    }

    private class PredicateExpression implements Expression {

        private final Qualifier qualifier;
        private PredicateExpression next;
        private boolean isNegated;

        PredicateExpression(Qualifier qualifier, boolean negated) {
            this.qualifier = qualifier;
            this.next = null;
            this.isNegated = negated;
        }

        /**
         * Chains the predicate using logical AND of this predicate and another.
         * @param other The other predicate
         */
        public void addNext(PredicateExpression other) {
            PredicateExpression tail = this;
            while (tail.next != null) {
                tail = tail.next;
            }
            tail.next = other;
        }

        @Override
        /**
         * Runs all the chained predicates using logical AND.
         * @param task Task to check
         * @return true if all predicates are satisfied
         */
        public boolean satisfies(ReadOnlyTask task) {
            PredicateExpression it = this;
            while (it != null) {
                if (it.qualifier.run(task) == it.isNegated) {
                    return false;
                }
                it = it.next;
            }
            return true;
        }

        @Override
        public String toString() {
            return qualifier.toString();
        }
    }
}
```
###### \java\teamfour\tasc\model\task\comparators\AToZComparator.java
``` java

package teamfour.tasc.model.task.comparators;

import java.util.Comparator;

import teamfour.tasc.model.task.ReadOnlyTask;

/**
 * Compares the ReadOnlyTask in ascending lexicographical order.
 */
public class AToZComparator implements Comparator<ReadOnlyTask> {

    @Override
    public int compare(ReadOnlyTask a, ReadOnlyTask b) {
        return a.getName().getName().compareTo(b.getName().getName());
    }
}
```
###### \java\teamfour\tasc\model\task\comparators\EarliestFirstComparator.java
``` java

package teamfour.tasc.model.task.comparators;

import java.util.Comparator;

import teamfour.tasc.model.task.ReadOnlyTask;

/**
 * Compares the ReadOnlyTask in ascending dates.
 */
public class EarliestFirstComparator implements Comparator<ReadOnlyTask> {
    
    @Override
    public int compare(ReadOnlyTask a, ReadOnlyTask b) {
        int timeA = 0;
        if (a.getDeadline().hasDeadline()) {
            timeA = (int)(a.getDeadline().getDeadline().getTime() / 1000);
        } else if (a.getPeriod().hasPeriod()) {
            timeA = (int)(a.getPeriod().getStartTime().getTime() / 1000);
        }

        int timeB = 0;
        if (b.getDeadline().hasDeadline()) {
            timeB = (int)(b.getDeadline().getDeadline().getTime() / 1000);
        } else if (b.getPeriod().hasPeriod()) {
            timeB = (int)(b.getPeriod().getStartTime().getTime() / 1000);
        }

        return timeA - timeB;
    }
}
```
###### \java\teamfour\tasc\model\task\comparators\LatestFirstComparator.java
``` java

package teamfour.tasc.model.task.comparators;

import java.util.Comparator;

import teamfour.tasc.model.task.ReadOnlyTask;

/**
 * Compares the ReadOnlyTask in descending dates.
 */
public class LatestFirstComparator implements Comparator<ReadOnlyTask> {
    
    @Override
    public int compare(ReadOnlyTask a, ReadOnlyTask b) {
        int timeA = 0;
        if (a.getDeadline().hasDeadline()) {
            timeA = (int)(a.getDeadline().getDeadline().getTime() / 1000);
        } else if (a.getPeriod().hasPeriod()) {
            timeA = (int)(a.getPeriod().getStartTime().getTime() / 1000);
        }

        int timeB = 0;
        if (b.getDeadline().hasDeadline()) {
            timeB = (int)(b.getDeadline().getDeadline().getTime() / 1000);
        } else if (b.getPeriod().hasPeriod()) {
            timeB = (int)(b.getPeriod().getStartTime().getTime() / 1000);
        }

        return timeB - timeA;
    }
}
```
###### \java\teamfour\tasc\model\task\comparators\ZToAComparator.java
``` java

package teamfour.tasc.model.task.comparators;

import java.util.Comparator;

import teamfour.tasc.model.task.ReadOnlyTask;

/**
 * Compares the ReadOnlyTask in descending lexicographical order.
 */
public class ZToAComparator implements Comparator<ReadOnlyTask> {
    
    @Override
    public int compare(ReadOnlyTask a, ReadOnlyTask b) {
        return b.getName().getName().compareTo(a.getName().getName());
    }
}
```
###### \java\teamfour\tasc\model\task\qualifiers\DeadlineQualifier.java
``` java

package teamfour.tasc.model.task.qualifiers;

import java.util.Date;

import teamfour.tasc.model.task.ReadOnlyTask;

/**
 * This qualifier allows tasks with deadlines
 * before the specified date to pass.
 */
public class DeadlineQualifier implements Qualifier {
    private Date deadline;

    public DeadlineQualifier(Date deadline) {
        assert deadline != null;
        this.deadline = deadline;
    }

    @Override
    public boolean run(ReadOnlyTask task) {
        assert task != null;
        if (task.getDeadline().hasDeadline() == false) {
            return false;
        }
        return deadline.after(task.getDeadline().getDeadline());
    }

    @Override
    public String toString() {
        return "deadline=" + deadline;
    }
}
```
###### \java\teamfour\tasc\model\task\qualifiers\EndTimeQualifier.java
``` java

package teamfour.tasc.model.task.qualifiers;

import java.util.Date;

import teamfour.tasc.model.task.ReadOnlyTask;

/**
 * This qualifier allows tasks with period or deadline
 * before the specified date to pass.
 */
public class EndTimeQualifier implements Qualifier {
    private Date endTime;

    public EndTimeQualifier(Date endTime) {
        assert endTime != null;
        this.endTime = endTime;
    }

    @Override
    public boolean run(ReadOnlyTask task) {
        assert task != null;
        if (task.getPeriod().hasPeriod()) {
            return endTime.after(task.getPeriod().getStartTime());
        } else if (task.getDeadline().hasDeadline()) {
            return endTime.after(task.getDeadline().getDeadline());
        }
        return true;
    }

    @Override
    public String toString() {
        return "endTime=" + endTime;
    }
}
```
###### \java\teamfour\tasc\model\task\qualifiers\StartTimeQualifier.java
``` java

package teamfour.tasc.model.task.qualifiers;

import java.util.Date;

import teamfour.tasc.model.task.ReadOnlyTask;

/**
 * This qualifier allows tasks with period or deadline
 * after the specified date to pass.
 */
public class StartTimeQualifier implements Qualifier {
    private Date startTime;

    public StartTimeQualifier(Date startTime) {
        assert startTime != null;
        this.startTime = startTime;
    }

    @Override
    public boolean run(ReadOnlyTask task) {
        assert task != null;
        if (task.getPeriod().hasPeriod()) {
            return startTime.before(task.getPeriod().getEndTime());
        } else if (task.getDeadline().hasDeadline()) {
            return startTime.before(task.getDeadline().getDeadline());
        }
        return true;
    }

    @Override
    public String toString() {
        return "startTime=" + startTime;
    }
}
```
###### \java\teamfour\tasc\model\task\qualifiers\StartToEndTimeQualifier.java
``` java

package teamfour.tasc.model.task.qualifiers;

import java.util.Date;

import teamfour.tasc.model.task.ReadOnlyTask;

/**
 * This qualifier allows tasks with period or deadline
 * exactly on the specified date to pass.
 */
public class StartToEndTimeQualifier implements Qualifier {
    private Date startTime;
    private Date endTime;

    public StartToEndTimeQualifier(Date startTime, Date endTime) {
        assert startTime != null;
        assert endTime != null;
        this.startTime = startTime;
        this.endTime = endTime;
    }

    @Override
    public boolean run(ReadOnlyTask task) {
        assert task != null;
        if (task.getPeriod().hasPeriod()) {
            return startTime.before(task.getPeriod().getEndTime()) &&
                    endTime.after(task.getPeriod().getStartTime());
        } else if (task.getDeadline().hasDeadline()) {
            return startTime.before(task.getDeadline().getDeadline()) &&
                    endTime.after(task.getDeadline().getDeadline());
        }
        return false;
    }

    @Override
    public String toString() {
        return "startTime=" + startTime + ",endTime=" + endTime;
    }
}
```
###### \java\teamfour\tasc\model\task\qualifiers\TagsQualifier.java
``` java

package teamfour.tasc.model.task.qualifiers;

import java.util.Set;

import teamfour.tasc.commons.util.StringUtil;
import teamfour.tasc.model.task.ReadOnlyTask;

/**
 * This qualifier allows tasks with any tag
 * which matches the specified tags to pass.
 */
public class TagsQualifier implements Qualifier {
    private Set<String> tagNames;

    public TagsQualifier(Set<String> tagNames) {
        assert tagNames != null;
        this.tagNames = tagNames;
    }

    @Override
    public boolean run(ReadOnlyTask task) {
        assert task != null;
        String taskTagsString = task.tagsString();
        taskTagsString = taskTagsString.replace("[", "");
        taskTagsString = taskTagsString.replace("]", "");
        String source = taskTagsString.replace(",", "");
        return tagNames.stream()
                .filter(tagName -> StringUtil.containsIgnoreCase(source, tagName))
                .findAny()
                .isPresent();
    }

    @Override
    public String toString() {
        return "tags=" + String.join(", ", tagNames);
    }
}
```
###### \java\teamfour\tasc\model\task\qualifiers\TypeQualifier.java
``` java

package teamfour.tasc.model.task.qualifiers;

import teamfour.tasc.model.task.ReadOnlyTask;

/**
 * This qualifier allows tasks with types
 * which match the specified types to pass.
 */
public class TypeQualifier implements Qualifier {
    private String type;

    public TypeQualifier(String type) {
        assert type != null;
        this.type = type;
    }

    @Override
    public boolean run(ReadOnlyTask task) {
        assert task != null;
        String[] typeWords = type.toLowerCase().split(" ");
        String taskType = (" " + task.getAsTypeKeywords()).toLowerCase();

        for (String typeWord : typeWords) {
            if (!taskType.contains(" " + typeWord)) {
                return false;
            }
        }
        return true;
    }

    @Override
    public String toString() {
        return "type=" + type;
    }
}
```
###### \java\teamfour\tasc\model\task\ReadOnlyTask.java
``` java
    public static String MATCHSTRING_TYPE_ALL = "All Everything";
    public static String MATCHSTRING_TYPE_COMPLETED = "Completed";
    public static String MATCHSTRING_TYPE_UNCOMPLETED = "Uncompleted Incompleted";
    public static String MATCHSTRING_TYPE_RECURRING = "Recurring Repeating";
    public static String MATCHSTRING_TYPE_OVERDUE = "Overdue Past";
    public static String MATCHSTRING_TYPE_TASKS_WITH_TIMESLOT = "Tasks Allocated Timeslot Deadline Period";
    public static String MATCHSTRING_TYPE_NORMAL_TASKS = "Normal Tasks Deadline";
    public static String MATCHSTRING_TYPE_FLOATING_TASKS = "Floating Tasks";
    public static String MATCHSTRING_TYPE_EVENTS = "Events Period";
    
```
###### \java\teamfour\tasc\model\task\ReadOnlyTask.java
``` java
    /**
     * Formats the task as keywords indicating its type from its attributes.
     */
    default String getAsTypeKeywords() {
        final StringBuilder builder = new StringBuilder();
        builder.append(" ").append(MATCHSTRING_TYPE_ALL);
        
        if (getComplete().isCompleted()) {
            builder.append(" ").append(MATCHSTRING_TYPE_COMPLETED);
        } else {
            builder.append(" ").append(MATCHSTRING_TYPE_UNCOMPLETED);
        }
        
        if (getRecurrence().hasRecurrence()) {
            builder.append(" ").append(MATCHSTRING_TYPE_RECURRING);
        }
        
        if (isOverdue(new Date())) {
            builder.append(" ").append(MATCHSTRING_TYPE_OVERDUE);
        }
        
        if (getDeadline().hasDeadline() && getPeriod().hasPeriod()) {
            builder.append(" ").append(MATCHSTRING_TYPE_TASKS_WITH_TIMESLOT);
        } else if (getDeadline().hasDeadline()) {
            builder.append(" ").append(MATCHSTRING_TYPE_NORMAL_TASKS);
        } else if (getPeriod().hasPeriod()) {
            builder.append(" ").append(MATCHSTRING_TYPE_EVENTS);
        } else {
            builder.append(" ").append(MATCHSTRING_TYPE_FLOATING_TASKS);
        }
        
        return builder.toString();
    }
```
###### \java\teamfour\tasc\model\TaskList.java
``` java
    @Override
    public TaskList createStateAsDeepCopy() {
        return new TaskList(this);
    }

```
###### \java\teamfour\tasc\model\TaskList.java
``` java
    /**
     * Precondition: Argument is not null.
     * Sort this task list by comparator.
     * Does affect the positions of tasks in the list internally.
     * 
     * @param comparator Comparator used to compare ReadOnlyTask
     */
    public void sortUsingComparator(Comparator<ReadOnlyTask> comparator) {
        assert comparator != null;
        FXCollections.sort(tasks.getInternalList(), comparator);
    }
```
###### \java\teamfour\tasc\ui\CalendarPanel.java
``` java
    /**
     * Precondition: argument is not null.
     * Change the view of the calendar.
     */
    public void changeView(String view) {
        assert view != null;
        
        switch(view) {
        case CalendarCommand.KEYWORD_CALENDAR_VIEW_DAY:
            agendaView.setSkin(new AgendaDaySkin(agendaView));
            currentCalendarView = CalendarCommand.KEYWORD_CALENDAR_VIEW_DAY;
            break;
        case CalendarCommand.KEYWORD_CALENDAR_VIEW_WEEK:
            agendaView.setSkin(new AgendaWeekSkin(agendaView));
            currentCalendarView = CalendarCommand.KEYWORD_CALENDAR_VIEW_WEEK;
            break;
        default:
            logger.warning("Calendar view type is not recognized: " + view);
            break;
        }
        selectLastSelectedTask();
    }
    
    /**
     * Selects and shows the given date on calendar.
     * @param date date to select
     */
    public void selectDate(Date date) {
        LocalDateTime time = date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();
        agendaView.setDisplayedLocalDateTime(time);
    }
    
```
###### \java\teamfour\tasc\ui\StatusBarFooter.java
``` java
    @Subscribe
    public void handleTaskListRenamedEvent(TaskListRenamedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        setSaveLocation(event.getNewPath());
    }
    
```
###### \java\teamfour\tasc\ui\UiManager.java
``` java
    /**
     * Handle the event when change calendar view is requested.
     */
    @Subscribe
    public void handleChangeCalendarViewRequestEvent(ChangeCalendarViewRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getCalendarPanel().changeView(event.getCalendarViewType());
        prefs.setCalendarView(event.getCalendarViewType());
    }

    /**
     * Handle the event when calendar is requested to jump to date.
     */
    @Subscribe
    public void handleJumpToCalendarDateRequestEvent(JumpToCalendarDateRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getCalendarPanel().selectDate(event.getDate());
    }

```
