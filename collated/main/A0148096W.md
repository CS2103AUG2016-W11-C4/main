# A0148096W
###### \java\teamfour\tasc\commons\events\ui\ChangeCalendarViewRequestEvent.java
``` java

package teamfour.tasc.commons.events.ui;

import teamfour.tasc.commons.events.BaseEvent;

/**
 * An event requesting to change the calendar view.
 */
public class ChangeCalendarViewRequestEvent extends BaseEvent {

    private final String calendarViewType;
    
    public ChangeCalendarViewRequestEvent(String calendarViewType) {
        this.calendarViewType = calendarViewType;
    }
    
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public String getCalendarViewType() {
        return calendarViewType;
    }
}
```
###### \java\teamfour\tasc\logic\commands\CalendarCommand.java
``` java

package teamfour.tasc.logic.commands;

import teamfour.tasc.commons.core.EventsCenter;
import teamfour.tasc.commons.events.ui.ChangeCalendarViewRequestEvent;
import teamfour.tasc.commons.exceptions.IllegalValueException;
import teamfour.tasc.model.keyword.CalendarCommandKeyword;
import teamfour.tasc.model.keyword.DayKeyword;
import teamfour.tasc.model.keyword.WeekKeyword;
import teamfour.tasc.ui.CalendarPanel;

/**
 * Changes the calendar view.
 */
public class CalendarCommand extends Command {

    public static final String COMMAND_WORD = CalendarCommandKeyword.keyword;

    public static final String KEYWORD_CALENDAR_VIEW_DAY = DayKeyword.keyword;
    public static final String KEYWORD_CALENDAR_VIEW_WEEK = WeekKeyword.keyword;
    
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Changes the calendar view. "
            + "Parameters: day (or) week\n"
            + "Example: " + COMMAND_WORD + " day";

    public static final String MESSAGE_SUCCESS = 
            "Calendar changed to %1$s view.";
    public static final String MESSAGE_FAILURE_ALREADY_IN_VIEW = 
            "Calendar is already in %1$s view.";

    private final String calendarView;
    
    /**
     * Calendar Command
     * Convenience constructor using raw values.
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public CalendarCommand(String calendarView) throws IllegalValueException {
        if (!isCalendarViewValid(calendarView)) {
            throw new IllegalValueException("Invalid calendar view type.");
        }
        this.calendarView = calendarView;
    }
    
    /**
     * Validates the calendar view String in the argument.
     */
    private boolean isCalendarViewValid(String calendarView) {
        if (calendarView != null &&
                (calendarView.equals(KEYWORD_CALENDAR_VIEW_DAY) ||
                calendarView.equals(KEYWORD_CALENDAR_VIEW_WEEK))) {
            return true;
        }
        return false;
    }

    @Override
    public CommandResult execute() {
        if (calendarView.equals(CalendarPanel.getCalendarView())) {
            return new CommandResult(String.format(
                    MESSAGE_FAILURE_ALREADY_IN_VIEW, calendarView));
        }
        
        EventsCenter.getInstance().post(new ChangeCalendarViewRequestEvent(calendarView));
        return new CommandResult(String.format(MESSAGE_SUCCESS, calendarView));
    }

    @Override
    public boolean canUndo() {
        return false;
    }
}
```
###### \java\teamfour\tasc\logic\commands\CommandHelper.java
``` java
    /**
     * Converts a String to Date if possible, otherwise returns null.
     * @param dateString the String containing the Date which may be null
     * @return the Date from String, or null if not possible
     */
    public static Date tryConvertStringToDateOrReturnNull(String dateString) {
        if (dateString != null) {
            try {
                return CommandHelper.convertStringToDate(dateString);
            } catch (IllegalValueException e) {
                logger.warning("Invalid date string in method " +
                            "convertStringToDateIfPossible: " + dateString);
                return null;
            }
        }
        return null;
    }

    /**
     * Precondition: date argument is not null.
     * Returns a Date object using date with time set to start of day.
     * @param date the Date object
     * @return a Date object set to start of the date
     */
    public static Date getStartOfTheDate(Date date) {
        assert date != null;
        Calendar c = Calendar.getInstance();
        c.setTime(date);
        c.set(Calendar.HOUR_OF_DAY, 0);
        c.set(Calendar.MINUTE, 0);
        c.set(Calendar.SECOND, 0);
        c.set(Calendar.MILLISECOND, 0);
        return c.getTime();
    }

    /**
     * Precondition: date argument is not null.
     * Returns a Date object using date with time set to end of day.
     * @param date the Date object
     * @return a Date object set to end of the date
     */
    public static Date getEndOfTheDate(Date date) {
        assert date != null;
        Calendar c = Calendar.getInstance();
        c.setTime(date);
        c.set(Calendar.HOUR_OF_DAY, 23);
        c.set(Calendar.MINUTE, 59);
        c.set(Calendar.SECOND, 59);
        c.set(Calendar.MILLISECOND, 999);
        return c.getTime();
    }
    
```
###### \java\teamfour\tasc\logic\commands\HideCommand.java
``` java

package teamfour.tasc.logic.commands;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

import teamfour.tasc.commons.exceptions.IllegalValueException;
import teamfour.tasc.model.keyword.ByKeyword;
import teamfour.tasc.model.keyword.FromKeyword;
import teamfour.tasc.model.keyword.HideCommandKeyword;
import teamfour.tasc.model.keyword.OnKeyword;
import teamfour.tasc.model.keyword.TagKeyword;
import teamfour.tasc.model.keyword.ToKeyword;

/**
 * Hides results from current listing results to the user that match the filters.
 */
public class HideCommand extends Command {
    public static final String COMMAND_WORD = HideCommandKeyword.keyword;
    
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Hides listing results with specified type, date or tags. "
            + "Parameters: [TYPE...] [on DATE] [by DEADLINE] [from START_TIME] [to END_TIME] [tag \"TAG\"...]\n"
            + "Example: " + COMMAND_WORD
            + " completed events";
    
    public static final String KEYWORD_DATE = OnKeyword.keyword;
    public static final String KEYWORD_DEADLINE = ByKeyword.keyword;
    public static final String KEYWORD_PERIOD_START_TIME = FromKeyword.keyword;
    public static final String KEYWORD_PERIOD_END_TIME = ToKeyword.keyword;
    public static final String KEYWORD_TAG = TagKeyword.keyword;
    
    public static final String[] VALID_KEYWORDS = { COMMAND_WORD, KEYWORD_DATE,
            KEYWORD_DEADLINE, KEYWORD_PERIOD_START_TIME, KEYWORD_PERIOD_END_TIME, KEYWORD_TAG};

    private final String type;
    private final Date deadline;
    private final Date startTime;
    private final Date endTime;
    private final Set<String> tags;
    private final boolean hasDate;
    
    /**
     * Show Command
     * Convenience constructor using raw values.
     * Set any parameter as null if it is not required.
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public HideCommand(String type, String date, String deadline, String startTime, 
                        String endTime, Set<String> tags) throws IllegalValueException {
        this.deadline = CommandHelper.tryConvertStringToDateOrReturnNull(deadline);
        Date convertedDate = CommandHelper.tryConvertStringToDateOrReturnNull(date);
        if (convertedDate != null) {
            hasDate = true;
            this.startTime = CommandHelper.getStartOfTheDate(convertedDate);
            this.endTime = CommandHelper.getEndOfTheDate(convertedDate);
        } else {
            hasDate = false;
            this.startTime = CommandHelper.tryConvertStringToDateOrReturnNull(startTime);
            this.endTime = CommandHelper.tryConvertStringToDateOrReturnNull(endTime);
        }
        
        this.tags = new HashSet<>();
        for (String tagName : tags) {
            this.tags.add(tagName);
        }
        this.type = type;
    }
    
    /**
     * Precondition: model is not null.
     * Adds the filters in this command to the model. 
     * Does not update the list yet.
     */
    private void addCommandFiltersToModel() {
        assert model != null;
        if (type != null)
            model.addTaskListFilterByType(type, true);
        if (deadline != null)
            model.addTaskListFilterByDeadline(deadline, true);
        if (hasDate) {
            model.addTaskListFilterByStartToEndTime(startTime, endTime, true);
        } else {
            if (startTime != null)
                model.addTaskListFilterByStartTime(startTime, true);
            if (endTime != null)
                model.addTaskListFilterByEndTime(endTime, true);
        }
        if (!tags.isEmpty())
            model.addTaskListFilterByTags(tags, true);
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        addCommandFiltersToModel();
        model.updateFilteredTaskListByFilter();
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }

    @Override
    public boolean canUndo() {
        return false;
    }

}
```
###### \java\teamfour\tasc\logic\commands\ListCommand.java
``` java

package teamfour.tasc.logic.commands;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

import teamfour.tasc.commons.exceptions.IllegalValueException;
import teamfour.tasc.model.Model;
import teamfour.tasc.model.keyword.ByKeyword;
import teamfour.tasc.model.keyword.FromKeyword;
import teamfour.tasc.model.keyword.ListCommandKeyword;
import teamfour.tasc.model.keyword.SortKeyword;
import teamfour.tasc.model.keyword.TagKeyword;
import teamfour.tasc.model.keyword.ToKeyword;

/**
 * Lists all tasks in the task list to the user with filters and sort.
 */
public class ListCommand extends Command {
    public static final String COMMAND_WORD = ListCommandKeyword.keyword;

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": List all tasks/events with filters. "
            + "Parameters: [TYPE...] [by DEADLINE] [from START_TIME] [to END_TIME] [tag \"TAG\"...] [sort SORTING_ORDER]\n"
            + "Example: " + COMMAND_WORD
            + " completed tasks, tag \"Important\", sort earliest first";

    public static final String KEYWORD_DEADLINE = ByKeyword.keyword;
    public static final String KEYWORD_PERIOD_START_TIME = FromKeyword.keyword;
    public static final String KEYWORD_PERIOD_END_TIME = ToKeyword.keyword;
    public static final String KEYWORD_TAG = TagKeyword.keyword;
    public static final String KEYWORD_SORT = SortKeyword.keyword;

    public static final String[] VALID_KEYWORDS = { COMMAND_WORD, KEYWORD_DEADLINE,
            KEYWORD_PERIOD_START_TIME, KEYWORD_PERIOD_END_TIME, KEYWORD_TAG, KEYWORD_SORT};

    private final String type;
    private final Date deadline;
    private final Date startTime;
    private final Date endTime;
    private final Set<String> tags;
    private final String sortOrder;

    /**
     * List Command with default values
     * Lists all uncompleted tasks and events from now.
     */
    public ListCommand() throws IllegalValueException {
        this.type = "uncompleted";
        this.deadline = null;
        this.startTime = null;
        this.endTime = null;
        this.tags = new HashSet<>();
        this.sortOrder = Model.SORT_ORDER_BY_EARLIEST_FIRST;
    }

    /**
     * List Command
     * Convenience constructor using raw values.
     * Set any parameter as null if it is not required.
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public ListCommand(String type, String deadline, String startTime, String endTime,
                        Set<String> tags, String sortingOrder) throws IllegalValueException {
        this.deadline = CommandHelper.tryConvertStringToDateOrReturnNull(deadline);
        this.startTime = CommandHelper.tryConvertStringToDateOrReturnNull(startTime);
        this.endTime = CommandHelper.tryConvertStringToDateOrReturnNull(endTime);

        this.tags = new HashSet<>();
        for (String tagName : tags) {
            this.tags.add(tagName);
        }
        this.type = type;
        this.sortOrder = sortingOrder;
    }

    /**
     * Precondition: model is not null.
     * Adds the filters in this command to the model.
     * Does not update the list yet.
     */
    private void addCommandFiltersToModel() {
        assert model != null;
        model.resetTaskListFilter();
        if (type != null)
            model.addTaskListFilterByType(type, false);
        if (deadline != null)
            model.addTaskListFilterByDeadline(deadline, false);
        if (startTime != null)
            model.addTaskListFilterByStartTime(startTime, false);
        if (endTime != null)
            model.addTaskListFilterByEndTime(endTime, false);
        if (!tags.isEmpty())
            model.addTaskListFilterByTags(tags, false);
    }

    @Override
    public CommandResult execute() {
        assert model != null;

        addCommandFiltersToModel();
        model.updateFilteredTaskListByFilter();

        if (sortOrder != null)
            model.sortFilteredTaskListByOrder(sortOrder);

        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }

    @Override
    public boolean canUndo() {
        return false;
    }

}
```
###### \java\teamfour\tasc\logic\commands\ShowCommand.java
``` java

package teamfour.tasc.logic.commands;

import java.util.Date;
import java.util.HashSet;
import java.util.Set;

import teamfour.tasc.commons.exceptions.IllegalValueException;
import teamfour.tasc.model.keyword.ByKeyword;
import teamfour.tasc.model.keyword.FromKeyword;
import teamfour.tasc.model.keyword.OnKeyword;
import teamfour.tasc.model.keyword.ShowCommandKeyword;
import teamfour.tasc.model.keyword.TagKeyword;
import teamfour.tasc.model.keyword.ToKeyword;

/**
 * Shows results from current listing results to the user that match the filters.
 */
public class ShowCommand extends Command {
    public static final String COMMAND_WORD = ShowCommandKeyword.keyword;
    
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Shows only listing results with specified type, date or tags. "
            + "Parameters: [TYPE...] [on DATE] [by DEADLINE] [from START_TIME] [to END_TIME] [tag \"TAG\"...]\n"
            + "Example: " + COMMAND_WORD
            + " events on 24 Sep, tag \"Important\"";

    public static final String KEYWORD_DATE = OnKeyword.keyword;
    public static final String KEYWORD_DEADLINE = ByKeyword.keyword;
    public static final String KEYWORD_PERIOD_START_TIME = FromKeyword.keyword;
    public static final String KEYWORD_PERIOD_END_TIME = ToKeyword.keyword;
    public static final String KEYWORD_TAG = TagKeyword.keyword;
    
    public static final String[] VALID_KEYWORDS = { COMMAND_WORD, KEYWORD_DATE,
            KEYWORD_DEADLINE, KEYWORD_PERIOD_START_TIME, KEYWORD_PERIOD_END_TIME, KEYWORD_TAG};

    private final String type;
    private final Date deadline;
    private final Date startTime;
    private final Date endTime;
    private final Set<String> tags;
    private final boolean hasDate;
    
    /**
     * Show Command
     * Convenience constructor using raw values.
     * Set any parameter as null if it is not required.
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public ShowCommand(String type, String date, String deadline, String startTime, 
                        String endTime, Set<String> tags) throws IllegalValueException {
        this.deadline = CommandHelper.tryConvertStringToDateOrReturnNull(deadline);
        Date convertedDate = CommandHelper.tryConvertStringToDateOrReturnNull(date);
        if (convertedDate != null) {
            hasDate = true;
            this.startTime = CommandHelper.getStartOfTheDate(convertedDate);
            this.endTime = CommandHelper.getEndOfTheDate(convertedDate);
        } else {
            hasDate = false;
            this.startTime = CommandHelper.tryConvertStringToDateOrReturnNull(startTime);
            this.endTime = CommandHelper.tryConvertStringToDateOrReturnNull(endTime);
        }
        
        this.tags = new HashSet<>();
        for (String tagName : tags) {
            this.tags.add(tagName);
        }
        this.type = type;
    }
    
    /**
     * Precondition: model is not null.
     * Adds the filters in this command to the model. 
     * Does not update the list yet.
     */
    private void addCommandFiltersToModel() {
        assert model != null;
        if (type != null)
            model.addTaskListFilterByType(type, false);
        if (deadline != null)
            model.addTaskListFilterByDeadline(deadline, false);
        if (hasDate) {
            model.addTaskListFilterByStartToEndTime(startTime, endTime, false);
        } else {
            if (startTime != null)
                model.addTaskListFilterByStartTime(startTime, false);
            if (endTime != null)
                model.addTaskListFilterByEndTime(endTime, false);
        }
        if (!tags.isEmpty())
            model.addTaskListFilterByTags(tags, false);
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        addCommandFiltersToModel();
        model.updateFilteredTaskListByFilter();
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }

    @Override
    public boolean canUndo() {
        return false;
    }

}
```
###### \java\teamfour\tasc\logic\commands\UndoCommand.java
``` java

package teamfour.tasc.logic.commands;

import teamfour.tasc.model.keyword.UndoCommandKeyword;
import teamfour.tasc.commons.exceptions.IllegalValueException;

/**
 * Undo the last (n) commands.
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = UndoCommandKeyword.keyword;

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Undo the last command(s). "
            + "Parameters: [Number of steps]\n"
            + "Example: " + COMMAND_WORD + " 5";

    public static final String MESSAGE_SUCCESS = "Last %1$s undone.";
    public static final String MESSAGE_NO_PAST_COMMAND_TO_UNDO = 
            "There is no past command to undo.";

    private final int numCommandsToBeUndone;
    
    /**
     * Default behavior of UndoCommand, undoes 1 command
     */
    public UndoCommand() throws IllegalValueException {
        this(1);
    }

    /**
     * Add Command for floating tasks
     * Convenience constructor using raw values.
     * @throws IllegalValueException if numCommandsToBeUndone is < 1
     */
    public UndoCommand(int numCommandsToBeUndone) throws IllegalValueException {
        if (numCommandsToBeUndone < 1) {
            throw new IllegalValueException("Number of undo must be positive.");
        }
        this.numCommandsToBeUndone = numCommandsToBeUndone;
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        
        int numUndone = model.undoTaskListHistory(numCommandsToBeUndone);
        
        if (numUndone == 0) {
            return new CommandResult(MESSAGE_NO_PAST_COMMAND_TO_UNDO);
        }
        return new CommandResult(String.format(MESSAGE_SUCCESS, 
                numUndone == 1 ? 
                "command" : numUndone + " commands"));
    }

    @Override
    public boolean canUndo() {
        return false;
    }

}
```
###### \java\teamfour\tasc\logic\parser\Parser.java
``` java
    /**
     * Takes in a string and return null if it is empty,
     * or otherwise returns the string itself.
     */
    private String setToNullIfIsEmptyString(String string) {
        if (string == null || string.equals("")) {
            return null;
        }
        return string;
    }

    /**
     * Precondition: argument is not null.
     * Takes in a string and remove all occurrences of full stops and commas.
     */
    private String removeFullStopsAndCommas(String string) {
        assert string != null;
        string = string.replace(",", "");
        string = string.replace(".", "");
        return string;
    }

    /**
     * Precondition: argument string is not null.
     * Parses the command string in the context of the list task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareList(String args){
        assert args != null;

        // No arguments, use default 'list' command
        if (args.trim().equals("")) {
            try {
                return new ListCommand();
            } catch (IllegalValueException ive) {
                return new IncorrectCommand(ive.getMessage());
            }
        }

        final KeywordParser parser = new KeywordParser(ListCommand.VALID_KEYWORDS);
        HashMap<String, String> parsed = parser.parseKeywordsWithoutFixedOrder(ListCommand.COMMAND_WORD + args);
        String type = setToNullIfIsEmptyString(parsed.get(ListCommand.COMMAND_WORD));
        String deadline = setToNullIfIsEmptyString(parsed.get(ListCommand.KEYWORD_DEADLINE));
        String startTime = setToNullIfIsEmptyString(parsed.get(ListCommand.KEYWORD_PERIOD_START_TIME));
        String endTime = setToNullIfIsEmptyString(parsed.get(ListCommand.KEYWORD_PERIOD_END_TIME));
        String tags = setToNullIfIsEmptyString(parsed.get(ListCommand.KEYWORD_TAG));
        String sortingOrder = setToNullIfIsEmptyString(parsed.get(ListCommand.KEYWORD_SORT));

        if(tags == null){
            tags = "";
        } else {
            tags = removeFullStopsAndCommas(tags);
        }

        if (sortingOrder != null) {
            sortingOrder = removeFullStopsAndCommas(sortingOrder);
        }

        try {
            return new ListCommand(
                    type,
                    deadline,
                    startTime,
                    endTime,
                    getTagsFromArgs(tags),
                    sortingOrder
            );
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /**
     * Precondition: argument string is not null.
     * Parses the command string in the context of the show command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareShow(String args){
        assert args != null;

        if (args.trim().equals("")) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ShowCommand.MESSAGE_USAGE));
        }

        final KeywordParser parser = new KeywordParser(ShowCommand.VALID_KEYWORDS);
        HashMap<String, String> parsed = parser.parseKeywordsWithoutFixedOrder(ShowCommand.COMMAND_WORD + args);
        String type = setToNullIfIsEmptyString(parsed.get(ShowCommand.COMMAND_WORD));
        String date = setToNullIfIsEmptyString(parsed.get(ShowCommand.KEYWORD_DATE));
        String deadline = setToNullIfIsEmptyString(parsed.get(ShowCommand.KEYWORD_DEADLINE));
        String startTime = setToNullIfIsEmptyString(parsed.get(ShowCommand.KEYWORD_PERIOD_START_TIME));
        String endTime = setToNullIfIsEmptyString(parsed.get(ShowCommand.KEYWORD_PERIOD_END_TIME));
        String tags = setToNullIfIsEmptyString(parsed.get(ShowCommand.KEYWORD_TAG));

        if(tags == null){
            tags = "";
        } else {
            tags = removeFullStopsAndCommas(tags);
        }

        try {
            return new ShowCommand(
                    type,
                    date,
                    deadline,
                    startTime,
                    endTime,
                    getTagsFromArgs(tags)
            );
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /**
     * Precondition: argument string is not null.
     * Parses the command string in the context of the hide command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareHide(String args){
        assert args != null;

        if (args.trim().equals("")) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HideCommand.MESSAGE_USAGE));
        }

        final KeywordParser parser = new KeywordParser(HideCommand.VALID_KEYWORDS);
        HashMap<String, String> parsed = parser.parseKeywordsWithoutFixedOrder(HideCommand.COMMAND_WORD + args);
        String type = setToNullIfIsEmptyString(parsed.get(HideCommand.COMMAND_WORD));
        String date = setToNullIfIsEmptyString(parsed.get(HideCommand.KEYWORD_DATE));
        String deadline = setToNullIfIsEmptyString(parsed.get(HideCommand.KEYWORD_DEADLINE));
        String startTime = setToNullIfIsEmptyString(parsed.get(HideCommand.KEYWORD_PERIOD_START_TIME));
        String endTime = setToNullIfIsEmptyString(parsed.get(HideCommand.KEYWORD_PERIOD_END_TIME));
        String tags = setToNullIfIsEmptyString(parsed.get(HideCommand.KEYWORD_TAG));

        if(tags == null){
            tags = "";
        } else {
            tags = removeFullStopsAndCommas(tags);
        }

        try {
            return new HideCommand(
                    type,
                    date,
                    deadline,
                    startTime,
                    endTime,
                    getTagsFromArgs(tags)
            );
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

```
###### \java\teamfour\tasc\logic\parser\Parser.java
``` java
    /**
     * Parses arguments in the context of the change calendar view command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareCalendar(String args) {
        if (args.equals("")) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, CalendarCommand.MESSAGE_USAGE));
        }
        try {
            return new CalendarCommand(args.trim());
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, CalendarCommand.MESSAGE_USAGE));
        }
    }

```
###### \java\teamfour\tasc\logic\parser\Parser.java
``` java
    /**
     * Parses arguments in the context of the undo command.
     * Special case: if no arg is provided, undoes 1 command.
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareUndo(String args) {
        if (args.equals("")) {
            try {
                return new UndoCommand();
            } catch (IllegalValueException ive) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UndoCommand.MESSAGE_USAGE));
            }
        }
        Optional<Integer> index = parseIndex(args);
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, UndoCommand.MESSAGE_USAGE));
        }

        try {
            return new UndoCommand(index.get());
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UndoCommand.MESSAGE_USAGE));
        }
    }
    
```
###### \java\teamfour\tasc\model\history\HistoryItem.java
``` java

package teamfour.tasc.model.history;

/**
 * An object that can be reverted to past states.
 * Must be able to be create deep copies of itself.
 * 
 * @param <T> The class of the item
 */
public interface HistoryItem<T> {
    /** creates the state of this object itself as a deep copy */
    T createStateAsDeepCopy();
}
```
###### \java\teamfour\tasc\model\history\HistoryStack.java
``` java

package teamfour.tasc.model.history;

import java.util.LinkedList;

/**
 * Stores and retrieves HistoryItems as a stack.
 * Automatically removes older items when max limit is reached.
 */
public class HistoryStack<T extends HistoryItem<T>> {

    /** Thrown when trying to pop an empty HistoryStack */
    public static class OutOfHistoryException extends Exception {
        protected OutOfHistoryException() {
            super("This history queue is empty.");
        }
    }
    
    private static final int DEFAULT_MAX_NUM_OF_STATES = 10;
    private final int maxNumOfStates;
    
    // Uses a LinkedList so that can removeFirst 
    // for states that are too old.
    private final LinkedList<T> historyLL;
    
    /**
     * Default constructor creates with default size.
     */
    public HistoryStack() {
        this(DEFAULT_MAX_NUM_OF_STATES);
    }
    
    /**
     * Precondition: maxNumOfStates is > 0.
     * Creates HistoryStack which can store up to
     * a number of history item states.
     * 
     * @param maxNumOfStates max number of history states
     */
    public HistoryStack(int maxNumOfStates) {
        assert maxNumOfStates > 0;
        this.maxNumOfStates = maxNumOfStates;
        historyLL = new LinkedList<T>();
    }
    
    /**
     * Precondition: item passed in argument is not null.
     * Pushes the object to be saved as a history state,
     * by adding its deep copy into this stack.
     * 
     * @param item Object to be saved
     */
    public void push(T item) {
        assert item != null;
        
        if (historyLL.size() >= maxNumOfStates) {
            historyLL.removeFirst();
        }
        historyLL.addLast(item.createStateAsDeepCopy());
    }
    
    /**
     * Pops and returns the latest history item stored.
     * 
     * @return The HistoryItem object
     * @throws OutOfHistoryException if the history queue is empty
     */
    public T pop() throws OutOfHistoryException {
        if (historyLL.size() <= 0)
            throw new OutOfHistoryException();
        
        return historyLL.removeLast();
    }
    
}
```
###### \java\teamfour\tasc\model\Model.java
``` java
    public static final String SORT_ORDER_BY_EARLIEST_FIRST = "earliest first";
    public static final String SORT_ORDER_BY_LATEST_FIRST = "latest first";
    public static final String SORT_ORDER_BY_A_TO_Z = "a-z";
    public static final String SORT_ORDER_BY_Z_TO_A = "z-a";

```
###### \java\teamfour\tasc\model\Model.java
``` java
    /** Saves the current state of the TaskList into history */
    void saveTaskListHistory();
    
    /**
     * Precondition: numToUndo must be > 0.
     * Reverts the task list to the most recent past state
     * @return number of history states undone
     */
    int undoTaskListHistory(int numToUndo);
    
```
###### \java\teamfour\tasc\model\Model.java
``` java
    /** Removes all filters of the filtered task list */
    void resetTaskListFilter();

    /**
     * Precondition: arguments are not null.
     * Adds the filter of the filtered task list by the given type
     */
    void addTaskListFilterByType(String type, boolean negated);

    /**
     * Precondition: arguments are not null.
     * Adds the filter of the filtered task list by the given deadline
     */
    void addTaskListFilterByDeadline(Date deadline, boolean negated);

    /**
     * Precondition: arguments are not null.
     * Adds the filter of the filtered task list by the given start time
     */
    void addTaskListFilterByStartTime(Date startTime, boolean negated);

    /**
     * Precondition: arguments are not null.
     * Adds the filter of the filtered task list by the given end time
     */
    void addTaskListFilterByEndTime(Date endTime, boolean negated);

    /**
     * Precondition: arguments are not null.
     * Adds the filter of the filtered task list by between start time and end time
     */
    void addTaskListFilterByStartToEndTime(Date startTime, Date endTime, boolean negated);

    /**
     * Precondition: arguments are not null.
     * Adds the filter of the filtered task list by the given tag names
     */
    void addTaskListFilterByTags(Set<String> tags, boolean negated);

    /**
     * Precondition: arguments are not null.
     * Sorts the filtered task list by the given sorting order
     */
    void sortFilteredTaskListByOrder(String sortOrder);

    /** Updates the filtered task list by the added filters */
    void updateFilteredTaskListByFilter();

```
###### \java\teamfour\tasc\model\ModelManager.java
``` java
    @Override
    public void saveTaskListHistory() {
        taskListHistory.push(taskList);
    }

    @Override
    public int undoTaskListHistory(int numToUndo) {
        assert numToUndo > 0;

        int numUndone = 0;
        TaskList historyTaskList = null;
        try {
            for (int i = 0; i < numToUndo; i++) {
                redoTaskListHistory.push(historyTaskList == null ? taskList : historyTaskList);
                historyTaskList = taskListHistory.pop();
                numUndone++;
            }
        } catch (OutOfHistoryException e) {
            logger.fine(e.getMessage());
        }

        if (historyTaskList != null) {
            resetData(historyTaskList);
        }
        return numUndone;
    }

```
###### \java\teamfour\tasc\model\ModelManager.java
``` java
    @Override
    public void resetTaskListFilter() {
        taskListFilter = new PredicateExpression(new AllQualifier());
    }

    @Override
    public void addTaskListFilterByType(String type, boolean negated) {
        assert type != null;
        taskListFilter.and(new PredicateExpression(new TypeQualifier(type), negated));
    }

    @Override
    public void addTaskListFilterByDeadline(Date deadline, boolean negated) {
        assert deadline != null;
        taskListFilter.and(new PredicateExpression(new DeadlineQualifier(deadline), negated));
    }

    @Override
    public void addTaskListFilterByStartTime(Date startTime, boolean negated) {
        assert startTime != null;
        taskListFilter.and(new PredicateExpression(new StartTimeQualifier(startTime), negated));
    }

    @Override
    public void addTaskListFilterByEndTime(Date endTime, boolean negated) {
        assert endTime != null;
        taskListFilter.and(new PredicateExpression(new EndTimeQualifier(endTime), negated));
    }

    @Override
    public void addTaskListFilterByStartToEndTime(Date startTime, Date endTime, boolean negated) {
        assert startTime != null;
        assert endTime != null;
        taskListFilter.and(new PredicateExpression(new StartToEndTimeQualifier(startTime, endTime), negated));
    }

    @Override
    public void addTaskListFilterByTags(Set<String> tags, boolean negated) {
        assert tags != null;
        taskListFilter.and(new PredicateExpression(new TagQualifier(tags), negated));
    }

    @Override
    public void sortFilteredTaskListByOrder(String sortOrder) {
        assert sortOrder != null;
        switch(sortOrder) {
        case Model.SORT_ORDER_BY_EARLIEST_FIRST:
            taskList.sortUsingComparator(new EarliestFirstComparator());
            break;
        case Model.SORT_ORDER_BY_LATEST_FIRST:
            taskList.sortUsingComparator(new LatestFirstComparator());
            break;
        case Model.SORT_ORDER_BY_A_TO_Z:
            taskList.sortUsingComparator(new AToZComparator());
            break;
        case Model.SORT_ORDER_BY_Z_TO_A:
            taskList.sortUsingComparator(new ZToAComparator());
            break;
        default:
            logger.warning("Unable to sort task list due to "
                    + "unrecognized sort order string: " + sortOrder);
            break;
        }
    }

    @Override
    public void updateFilteredTaskListByFilter() {
        updateFilteredTaskList(taskListFilter);
    }

```
###### \java\teamfour\tasc\model\ModelManager.java
``` java
    //========== Inner classes/interfaces used for filtering ==================================================

    interface Expression {
        boolean satisfies(ReadOnlyTask task);
        String toString();
    }

    private class PredicateExpression implements Expression {

        private final Qualifier qualifier;
        private PredicateExpression and;
        private boolean isNegated;

        PredicateExpression(Qualifier qualifier) {
            this(qualifier, false);
        }

        PredicateExpression(Qualifier qualifier, boolean negated) {
            this.qualifier = qualifier;
            this.and = null;
            this.isNegated = negated;
        }

        /**
         * Chains the predicate using logical AND of this predicate and another.
         * @param and The other predicate
         */
        public void and(PredicateExpression other) {
            PredicateExpression tail = this;
            while (tail.and != null) {
                tail = tail.and;
            }
            tail.and = other;
        }

        @Override
        /**
         * Runs all the chained predicates using logical AND.
         * @param task Task to check
         * @return true if all predicates are satisfied
         */
        public boolean satisfies(ReadOnlyTask task) {
            PredicateExpression it = this;
            while (it != null) {
                if (it.qualifier.run(task) == it.isNegated) {
                    return false;
                }
                it = it.and;
            }
            return true;
        }

        @Override
        public String toString() {
            return qualifier.toString();
        }
    }

    interface Qualifier {
        boolean run(ReadOnlyTask task);
        String toString();
    }

    private class AllQualifier implements Qualifier {
        AllQualifier() {}

        @Override
        public boolean run(ReadOnlyTask task) {
            return true;
        }

        @Override
        public String toString() {
            return "all qualifier";
        }
    }

    private class NameQualifier implements Qualifier {
        private Set<String> nameKeyWords;

        NameQualifier(Set<String> nameKeyWords) {
            this.nameKeyWords = nameKeyWords;
        }
```
###### \java\teamfour\tasc\model\task\ReadOnlyTask.java
``` java
    public static String MATCHSTRING_TYPE_ALL = "All Everything";
    public static String MATCHSTRING_TYPE_COMPLETED = "Completed";
    public static String MATCHSTRING_TYPE_UNCOMPLETED = "Uncompleted Incompleted";
    public static String MATCHSTRING_TYPE_RECURRING = "Recurring Repeating";
    public static String MATCHSTRING_TYPE_OVERDUE = "Overdue Past";
    public static String MATCHSTRING_TYPE_TASKS_WITH_TIMESLOT = "Tasks Allocated Timeslot Deadline Period";
    public static String MATCHSTRING_TYPE_NORMAL_TASKS = "Normal Tasks Deadline";
    public static String MATCHSTRING_TYPE_FLOATING_TASKS = "Floating Tasks";
    public static String MATCHSTRING_TYPE_EVENTS = "Events Period";
    
```
###### \java\teamfour\tasc\model\task\ReadOnlyTask.java
``` java
    /**
     * Formats the task as keywords indicating its type from its attributes.
     */
    default String getAsTypeKeywords() {
        final StringBuilder builder = new StringBuilder();
        builder.append(" ").append(MATCHSTRING_TYPE_ALL);
        
        if (getComplete().isCompleted()) {
            builder.append(" ").append(MATCHSTRING_TYPE_COMPLETED);
        } else {
            builder.append(" ").append(MATCHSTRING_TYPE_UNCOMPLETED);
        }
        
        if (getRecurrence().hasRecurrence()) {
            builder.append(" ").append(MATCHSTRING_TYPE_RECURRING);
        }
        
        if (isOverdue(new Date())) {
            builder.append(" ").append(MATCHSTRING_TYPE_OVERDUE);
        }
        
        if (getDeadline().hasDeadline() && getPeriod().hasPeriod()) {
            builder.append(" ").append(MATCHSTRING_TYPE_TASKS_WITH_TIMESLOT);
        } else if (getDeadline().hasDeadline()) {
            builder.append(" ").append(MATCHSTRING_TYPE_NORMAL_TASKS);
        } else if (getPeriod().hasPeriod()) {
            builder.append(" ").append(MATCHSTRING_TYPE_EVENTS);
        } else {
            builder.append(" ").append(MATCHSTRING_TYPE_FLOATING_TASKS);
        }
        
        return builder.toString();
    }
```
###### \java\teamfour\tasc\model\TaskList.java
``` java
    /**
     * Precondition: Argument is not null.
     * Sort this task list by comparator.
     * Does affect the positions of tasks in the list internally.
     * 
     * @param comparator Comparator used to compare ReadOnlyTask
     */
    public void sortUsingComparator(Comparator<ReadOnlyTask> comparator) {
        assert comparator != null;
        FXCollections.sort(tasks.getInternalList(), comparator);
    }
```
###### \java\teamfour\tasc\ui\CalendarPanel.java
``` java
    /**
     * Precondition: argument is not null.
     * Change the view of the calendar.
     */
    public void changeView(String view) {
        assert view != null;
        
        switch(view) {
        case CalendarCommand.KEYWORD_CALENDAR_VIEW_DAY:
            agendaView.setSkin(new AgendaDaySkin(agendaView));
            currentCalendarView = CalendarCommand.KEYWORD_CALENDAR_VIEW_DAY;
            break;
        case CalendarCommand.KEYWORD_CALENDAR_VIEW_WEEK:
            agendaView.setSkin(new AgendaWeekSkin(agendaView));
            currentCalendarView = CalendarCommand.KEYWORD_CALENDAR_VIEW_WEEK;
            break;
        default:
            logger.warning("Calendar view type is not recognized: " + view);
            break;
        }
        selectLastSelectedTask();
    }
    
```
###### \java\teamfour\tasc\ui\UiManager.java
``` java
    /**
     * Handle the event when change calendar view is requested.
     */
    @Subscribe
    public void handleChangeCalendarViewRequestEvent(ChangeCalendarViewRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getCalendarPanel().changeView(event.getCalendarViewType());
        prefs.setCalendarView(event.getCalendarViewType());
    }

```
